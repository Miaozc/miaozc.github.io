{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于","text":"心怀恐惧，方能无畏。","link":"/about/index.html"},{"title":"Archives","text":"","link":"/archives/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"搭建hexo blog","text":"一、设置SSH1.多ssh配置执行 原因：由于本地已为gitee创建过默认公钥“id_rsa”，发布到github需单独配置公钥 使用git bash执行命令如下： 123456789101112$ cd ~$ md .ssh $ ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;Enter file in which to save the key (/c/Users/hp/.ssh/id_rsa):my_github$ ssh-agent bash$ ssh-add my_github$ ssh-add -l$ cat my_github.pub复制内容到github ssh keys$ ssh -T git@my_github.github.comHi UserName! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 二、hexo搭建1.hexo _config.yml配置 更改如下代码： 12345deploy:type: gitrepo: git@my_github.github.com:xxx/xxx.github.io.gitbranch: master my_github是上面配置的公钥名称 注意：每个参数后面“：”紧接着要写一个空格，不能直接跟value，否则构建失败2.hexo 常用基本语法 hexo clean 清空public文件夹 hexo g 构建 hexo s 启动server hexo d 推送到git hub hexo new xx创建名为“xx”的文章","link":"/2019/04/14/搭建hexo博客/"},{"title":"设计模式（七）：委派模式","text":"委派模式委派模式（Delegate Pattern）的基本作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。委派模式在 Spring 中应用非常多，大家常用的 DispatcherServlet 其实就是用到了委派模式。现实生活中也常有委 派的场景发生，例如：老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板。","link":"/2019/08/08/design-2019-08-设计模式（七）：委派模式/"},{"title":"设计模式（一）：单例模式","text":"单例模式的应用场景单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。 例如，国家主席、公司 CEO、部门经理等。在 J2EE标准中，ServletContext、 ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext；数据库的连接池也都是单例形式。 常见实现饿汉式单例：Spring中IOC容器ApplicationContext。 饿汉式单例饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题。 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。 12345678910111213public class HungrySingleton { //法1 private static final HungrySingleton instance = new HungrySingleton(); //法2 // static { // instance = new HungrySingleton(); // } private HungrySingleton() { } public static HungrySingleton getInstance(){ return instance; }} 懒汉式单例懒汉式单例的特点是：被外部类调用的时候内部类才会加载. 1.同步锁懒汉式单例1234567891011private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; public static LazyDoubleCheckSingleton getInstance(){ if(lazyDoubleCheckSingleton ==null){ synchronized(LazyDoubleCheckSingleton.class){ if(lazyDoubleCheckSingleton ==null){ lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); } } } return lazyDoubleCheckSingleton; } 2.内部类懒汉式单例123456789101112131415161718192021public class LazyInnerClassSingleton { private LazyInnerClassSingleton() { System.out.println(\"构造方法\"); if (LazyHolder.LAZY!=null){ throw new RuntimeException(\"禁止通过反射创建此单例对象\"); } } public static final LazyInnerClassSingleton getInstance(){ System.out.println(\"getInstance\"); return LazyHolder.LAZY; } /** * 内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。 */ private static class LazyHolder{ private static final LazyInnerClassSingleton LAZY= new LazyInnerClassSingleton(); } public static void main(String []s ){ LazyInnerClassSingleton.getInstance(); }} 注册式单例1.容器缓存注册式单例123456789101112131415161718192021222324252627282930public class ContainerSingleton { private ContainerSingleton() { } private static final Map&lt;String,Object&gt; instanceMap = new HashMap&lt;&gt;(); public static final Object getBean(String className){ if(className==null||\"\".equals(className.trim())) return null; synchronized(instanceMap){ if (instanceMap.containsKey(className)){ return instanceMap.get(className); }else{ Object obj = null; try { Class clazz = Class.forName(className); obj = clazz.newInstance(); instanceMap.put(className,obj); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } return obj; } } }} 2.枚举注册式单例此方法即使通过反序列化也能获得单例 123456789101112131415public enum EnumSingleton { INSTANCE; private Object data; public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static EnumSingleton getInstance(){ return INSTANCE; }}","link":"/2019/08/04/design-2019-08-设计模式（一）：单例模式/"},{"title":"设计模式（三）：装饰者模式","text":"装饰者模式定义装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对 象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。 装饰模式主要包含以下角色。 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 样例定义抽象构件 123public interface IComponent { void operation();} 实现具体构件 123456public class ConcreteComponent implements IComponent{ @Override public void operation() { System.out.println(\"执行基本操作~\"); }} 定义抽象装饰（抽象可选） 123456789101112public abstract class AbstDecorator implements IComponent{ private IComponent component; public AbstDecorator(IComponent component) { this.component = component; } @Override public void operation() { System.out.println(\"执行抽象装饰\"); component.operation(); }} 实现具体装饰 123456789101112131415public class ConcreteDecorator extends AbstDecorator { public ConcreteDecorator(IComponent component) { super(component); } @Override public void operation() { method1(); super.operation(); } public void method1(){ System.out.println(\"执行附加的装饰方法\"); }} 测试 1234567public class DecoratorTest { public static void main(String[] args) { IComponent component = new ConcreteComponent(); IComponent d1 = new ConcreteDecorator(component); d1.operation(); }} console打印如下： 执行附加的装饰方法执行抽象装饰执行基本操作~ jdk典型装饰者场景：InputStream 与适配器模式的区别 装饰者模式 适配器模式 形式 是一种特殊的适配器模式 没有层级关系，装饰者有层级关系 定义 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留OOP关系 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 关系 满足is-a的关系 满足has-a的关系 功能 注重覆盖、扩展 注重兼容、转换 设计 前置考虑 后置考虑（重构） 优缺点优点 装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。 装饰者完全遵守开闭原则。 缺点 会出现更多的代码，更多的类，增加程序复杂性。 动态装饰时，多层装饰时会更复杂。","link":"/2019/08/08/design-2019-08-设计模式（三）：装饰者模式/"},{"title":"设计模式（九）：观察者模式","text":"观察者模式定义观察者模式（Observer Pattern）定义了对象之间的一对多依赖，让多个观察者对象同 时监听一个主体对象，当主体对象发生变化时，它的所有依赖者（观察者）都会收到通 知并更新，属于行为型模式。观察者模式有时也叫做发布订阅模式。观察者模式主要用 于在关联行为之间建立一套触发机制的场景。 JDK 原生支持实现样例被观察者，也称发布者 1234567891011121314/** * 被观察者对象 * Created by miaozc on 2019-8-8. */public class ConcreteObservable extends Observable { /** * 发布一个事件 */ public void publishEvent(ObserveContext context){ setChanged(); System.out.println(\"发布一个事件\"+context.getName()); notifyObservers(context); }} 观察者，也称订阅者 1234567891011121314151617/** * 观察者 * Created by miaozc on 2019-8-8. */public class ConcreteObserver implements Observer { private String name ; public ConcreteObserver(String name) { this.name = name; } @Override public void update(Observable o, Object arg) { ConcreteObservable observable = (ConcreteObservable) o; ObserveContext context = (ObserveContext) arg; System.out.println(name+\"已接收到\"+context.getName()+\"的事件\"); }} 定义参数、上下文 123456789101112131415161718/** * 发布订阅上下文 * Created by miaozc on 2019-8-8. */public class ObserveContext { private String name; public ObserveContext(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 开始测试 123456789101112131415/** * 测试观察者 * Created by miaozc on 2019-8-8. */public class TestObserver { public static void main(String[] args) { ObserveContext context = new ObserveContext(\"Event 1\"); ConcreteObservable observable =new ConcreteObservable(); ConcreteObserver observer = new ConcreteObserver(\"观察者一号\"); ConcreteObserver observer2 = new ConcreteObserver(\"观察者二号\"); observable.addObserver(observer); observable.addObserver(observer2); observable.publishEvent(context); }} console打印结果： 发布一个事件Event 1观察者二号已接收到Event 1的事件观察者一号已接收到Event 1的事件 类图 原生的观察者模式是线程安全的。但在数据量大、多线程模式下，需要考虑性能问题。可以选择Object.notify()机制代替之。","link":"/2019/08/08/design-2019-08-设计模式（九）：观察者模式/"},{"title":"设计模式（八）：策略模式","text":"策略模式策略模式（Strategy Pattern）是指定义了算法家族、分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。 策略模式的应用场景1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。 2、一个系统需要动态地在几种算法中选择一种。 策略模式在 JDK 源码中的体现首先来看一个比较常用的比较器 Comparator 接口，我们看到的一个大家常用的compare()方法，就是一个策略抽象实现： 1234public interface Comparator&lt;T&gt; { int compare(T o1, T o2); ... } Comparator 抽象下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作为排序策略，例如 Arrays 类的 parallelSort 方法等： 1234567public class Arrays { ... public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; cmp) { ... } ... } 策略模式在 Spring 源码中的应用Spring 的初始化也采用了策略模式，不同的类型的类采用不同的初始化策略。 12345public interface InstantiationStrategy { Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, Constructor&lt;?&gt; var4, @Nullable Object... var5) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, @Nullable Object var4, Method var5, @Nullable Object... var6) throws BeansException; } 顶层的策略抽象非常简单，但是它下面有两种策略 SimpleInstantiationStrategy 和CglibSubclassingInstantiationStrategy 123public class SimpleInstantiationStrategy implements InstantiationStrategy { ...} 123public class CglibSubclassingInstantiationStrategy extends SimpleInstantiationStrategy { ...} 说明在实际应用中多种策略之间还可以继承使用 策略模式的优缺点优点： 1、策略模式符合开闭原则。 2、避免使用多重条件转移语句，如 if…else…语句、switch 语句 3、使用策略模式可以提高算法的保密性和安全性。 缺点： 1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。 2、代码中会产生非常多策略类，增加维护难度。","link":"/2019/08/08/design-2019-08-设计模式（八）：策略模式/"},{"title":"设计模式（五）：模板方法模式","text":"模板方法模式定义模板模式通常又叫模板方法模式（Template Method Pattern）是指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤，属于行为性设计模式。模板方法适用于以下应用场景： 1、一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 2、各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。 示例 定义模板 12345678910111213public abstract class AbstTemplateMethod { public void templateMethod1(int p){ //抽象业务逻辑与模板逻辑灵活应用 p = p+10; p = method1(p); print(p); } abstract int method1(int p); private void print(int p){ System.out.println(p); }} 定义模板第一个业务类 1234567public class TemplateMethod1 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod1 p=\"); return p+1; }} 定义模板第二个业务类 1234567public class TemplateMethod2 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod2 p=\"); return p+2; }} 定义模板第n个业务类…. 测试 12345678public class TestTemplateMethod { public static void main(String[] args) { AbstTemplateMethod test = new TemplateMethod1(); test.templateMethod1(10); test = new TemplateMethod2(); test.templateMethod1(10); }}","link":"/2019/08/08/design-2019-08-设计模式（五）：模板方法模式/"},{"title":"设计模式（二）：代理模式","text":"代理模式（Proxy Pattern）定义是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用代理模式主要有两个目的：一、保护目标对象，二、增强目标对象。 常见实现SpringAop 静态代理（static proxy）抽象的说，就是代理对象持有被代理对象的引用进行方法增强。举个例子：在深圳租房子，我们自己去找房很难直接联系上房东。一般会联系中介或者管理处（proxy），间接的租房。有的全权代理的房东坐等收钱，而中介可以在收租前后做各种不需要告诉老板的事，比如装修一番再涨个价赚取中间商差价。 动态代理（dynamic proxy）动态，指的是不直接引用被代理对象，并且可以代理不同的对象。Spring AOP面向切面编程的原理正是如此。举个例子，快递公司要帮人寄送快递，但他不需要知道那个人是谁。只要按流程填写快递单就行了。“快递单”在这里就是被代理对象。沿用这个例子展开分析。 1.JDK Proxy12345678910111213141516171819202122232425/** * Created by miaozc on 2019-8-2. * 快递公司-动态代理发送快递 */public class ExpressCompanyJDKProxy implements InvocationHandler { private Object target; public Object getInstance(Object object)throws Exception{ this.target = object; Class&lt;?&gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object object = method.invoke(this.target,args); send(); return object; } public void send(){ System.out.println(\"jdk动态代理-快递公司发出快递！\"); }} 测试代码：12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));jdkCustomer.send(); JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。JDK Proxy 生成对象的步骤如下： 拿到被代理对象的引用，反射获取它所有的接口。 JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。 动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。 编译新生成的 Java 代码: $Proxy***.class。 再重新加载到 JVM 中运行。 以上这个过程就叫字节码重组。JDK 中有一个规范，在 ClassPath 下只要是$开头的 class文件一般都是自动生成的。查看代替后对象方式如下： 12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));byte [] bytes = ProxyGenerator.generateProxyClass(\"$Proxy0\",new Class[]{Person.class}); FileOutputStream os = new FileOutputStream(\"E://$Proxy0.class\"); 2. CGLib Proxy与JDK代理不同，CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现的动态代理。这样的做法弊端就是无法代理final关键字修饰的方法。.好处则更加明显，在频繁调用代理的情况下，省去了反射带来的开销。 代理实现： 12345678910111213141516171819202122232425public class ExpressCompanyCGLibProxy implements MethodInterceptor { public Object getInstance(Class&lt;?&gt; clazz,Class[] argumentTypes, Object[] arguments) throws Exception{ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); if(argumentTypes==null){ return enhancer.create(); }else{ return enhancer.create(argumentTypes, arguments); } } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { Object object = methodProxy.invokeSuper(o,objects); send(); return object; } public void send(){ System.out.println(\"cglib动态代理-快递公司发出快递！\"); }} 测试代码： 12345678910111213//构造方法所需参数Class[] argumentTypes = new Class[]{String.class};Object[] personArguments = new Object[]{\"王五\"};Object[] robotArguments = new Object[]{\"二哈\"};Customer cglibCustomer = (Customer) new ExpressCompanyCGLibProxy(). getInstance(Customer.class,argumentTypes,personArguments);Robot cglibRobot = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,argumentTypes,robotArguments);Robot cglibRobotCreate = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,null,null);cglibCustomer.send();cglibRobot.send();cglibRobotCreate.send(); 将 CGLib 代理后的 class 写入到磁盘： 1234//利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,\"E://cglib_proxy_class/\");ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\")); 我们会发现在 E://cglib_proxy_class 目录下多了三个 class 文件 ObjectName$$EnhancerByCGLIB$$3feeb52a.class CGLib生成的代理类，继承了被代理对象。重写了 被代理对象类的所有方法，并且生成代理的方法的增强逻辑以及增强逻辑所需要的方法。这直接导致了我们如果在拦截器里直接调用method.invoke()会死循环。所以我们切记在代理拦截器中应该使用methodProxy.invokeSuper(o,objects)。 ObjectName$$EnhancerByCGLIB$$3feeb52a$$FastClassByCGLIB$$6aad62f1.class 代理类的 FastClass。 Customer$$FastClassByCGLIB$$2669574a.class 被代理类的FastClass。 CGLib 动态代理执行代理方法效率之所以比 JDK的高是因为 Cglib 采用了 FastClass 机制，它的原理简单来说就是：为代理类和被代理类各生成一个 Class，这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高。FastClass 并不是跟代理类一块生成的，而是在第一次执行 MethodProxy.invoke()/invokeSuper() 时生成的并放在了缓存中。 CGLib 和 JDK 动态代理对比 JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。 JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。 Spring中的代理模式代理模式选择 当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理 当 Bean 没有实现接口时，Spring 选择 CGLib。 Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码： 1&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 静态代理和动态的本质区别 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。 代理模式的优缺点使用代理模式具有以下几个优点： 代理模式能将代理对象与真实被调用的目标对象分离。 一定程度上降低了系统的耦合度，扩展性好。 可以起到保护目标对象的作用。 可以对目标对象的功能增强。 当然，代理模式也是有缺点的： 代理模式会造成系统设计中类的数量增加。 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。 增加了系统的复杂度。","link":"/2019/08/04/design-2019-08-设计模式（二）：代理模式/"},{"title":"设计模式：分类","text":"设计模式的分类跟据其目的（模式是用来做什么的）一、创建型(Creational)创建型模式主要用于创建对象。 抽象工厂模式(Abstract Factory) 建造者模式(Builder) 工厂方法模式(Factory Method) 原型模式(Prototype) 单例模式(Singleton) 二、结构型(Structural)结构型模式主要用于处理类或对象的组合。 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 三、行为型模式行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。 职责链模式(Chain of Responsibility) 命令模式(Command) 解释器模式(Interpreter) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Visitor) 根据范围（模式主要是用于处理类之间关系还是处理对象之间的关系）可分为类模式和对象模式两种 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是属于静态的。 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。","link":"/2019/08/04/design-2019-08-设计模式：分类/"},{"title":"设计模式（四）：适配器模式","text":"适配器模式适配器模式（Adapter Pattern）是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作，属于结构型设计模式。 适配器适用于以下几种业务场景： 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。 生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。在中国民用电都是220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我们给手机充电时就需要使用电源适配器来进行转换。下面我们有代码来还原这个生活场 景，创建 AC220 类，表示 220V 交流电： 老版本逻辑 1234567public class AC220 { public int outputAC220V() { int output = 220; System.out.println(\"输出交流电\" + output + \"V\"); return output; }} 创建适配器接口 123public interface DC5 { int outputDC5V();} 创建适配器 123456789101112131415public class PowerAdapter implements DC5 { private AC220 ac220; public PowerAdapter(AC220 ac220) { this.ac220 = ac220; } @Override public int outputDC5V() { int adapterInput = ac220.outputAC220V(); //变压器 int adapterOutput = adapterInput / 44; System.out.println(\"使用 PowerAdapter 输入 AC:\" + adapterInput + \"V\" + \"输出 DC:\" + adapterOutput + \"V\"); return adapterOutput; }} 测试适配器 123456public class TestAdapter { public static void main(String[] args) { DC5 dc5 = new PowerAdapter(new AC220()); dc5.outputDC5V(); }} 适配器模式的优缺点优点 能提高类的透明性和复用，现有的类复用但不需要改变。 目标类和适配器类解耦，提高程序的扩展性。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。","link":"/2019/08/08/design-2019-08-设计模式（四）：适配器模式/"},{"title":"设计模式：七大原则","text":"软件架构设计的七大原则一、开闭原则开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调 的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开 闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统， 例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间， 规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。 二、依赖倒置原则依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模 块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖 抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的 可读性和可维护性，并能够降低修改程序所造成的风险。 三、单一职责原则单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更 的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的 逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现， 进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的 可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个 Class/Interface/Method 只负责一项职责。 四、接口隔离原则接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点： 1、一个类对一类的依赖应该建立在最小的接口之上。 2、建立单一接口，不要建立庞大臃肿的接口。 3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。 接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解 是非常重要的。 五、迪米特法则迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又 叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪 米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 六、里氏替换原则里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对 象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对 象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下： 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类 方法的输入参数更宽松。 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即 方法的输出/返回值）要比父类更严格或相等。 使用里氏替换原则有以下优点： 约束继承泛滥，开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩 展性。降低需求变更时引入的风险。 里氏替换原则只存在父类与子类之间，约束继承泛滥。 七、合成复用原则合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组 合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。 设计原则总结学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都 遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的 场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。","link":"/2019/08/04/design-2019-08-设计模式：七大原则/"},{"title":"Spring源码分析","text":"Spring初探全文参考Spring官方文档： https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/index.html 一、Spring5 框架介绍 核心容器由spring-beans、spring-core、spring-context和spring-expression（Spring Expression Language, SpEL） 4 个模块组成。spring-core 和 spring-beans 模块是 Spring 框架的核心模块，包含了控制反转（Inversion ofControl, IOC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是 Spring 框架中的核心接口，它是工厂模式的具体实现。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-context 模块构架于核心模块之上，他扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，她的超类是 BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。 spring-context-support 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。 spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。 spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计，他可以非常方便地同 Spring IOC 进行交互。 AOP 和设备支持由 spring-aop、spring-aspects 和 spring-instrument 3 个模块组成。 spring-aop 是 Spring 的另一个核心模块，是 AOP 主要的实现模块。作为继 OOP 后，对程序员影 响最大的编程思想之一，AOP 极大地开拓了人们对于编程的思路。在 Spring 中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的 AOP 横切实现，比如前置通知、返回通知、异常通知等，同时，Pointcut 接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求 进行切入。 spring-aspects 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。 spring-instrument 模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP 的一个支援模块，主要作用是在 JVM 启用时，生成一个代理类，程序员通过代理类在运行时修改类的 字节，从而改变一个类的功能，实现 AOP 的功能。在分类里，我把他分在了 AOP 模块下，在 Spring 官 方文档里对这个地方也有点含糊不清，这里是纯个人观点。 数据访问与集成由 spring-jdbc、spring-tx、spring-orm、spring-jms 和 spring-oxm 5 个模块组成。 spring-jdbc 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。 主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程， 主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。 spring-tx 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架，它对事务做了很好的封装， 通过它的 AOP 配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用 JDBC 事务控 制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法； 如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计 则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所 以，在使用 Spring JDBC 事务控制时，应该注意其特殊性。 spring-orm 模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和 Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。 spring-oxm 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写， 它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象），例如： JAXB, Castor, XMLBeans, JiBX 和 XStream 等。 spring-jms 模块（Java Messaging Service）能够发送和接收信息，自 Spring Framework 4.1 以 后，他还提供了对 spring-messaging 模块的支撑。 Web 组件由 spring-web、spring-webmvc、spring-websocket 和 spring-webflux 4 个模块组成。 spring-web 模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或 者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持。 spring-webmvc 模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC （model-view-Controller）的 Web 应用。 spring-websocket 模块主要是与 Web 前端的全双工通讯的协议。 spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。 集成测试即 spring-test 模块，主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。 集成兼容即 spring-framework-bom 模块，Bill of Materials.解决 Spring 的不同模块依赖版本不同问题。 各模块之间的依赖关系 Spring 版本命名规则 描述方式 说明 含义 Snapshot 快照版 尚不不稳定、尚处于开发中的版本 Release 稳定版 功能相对稳定，可以对外发行，但有时间限制 GA 正式版 代表广泛可用的稳定版(General Availability) M 里程碑版 (M 是 Milestone 的意思）具有一些全新的功能或是具有里程碑意义 的版本。 RC 终测版 Release Candidate（最终测试），即将作为正式版发布。","link":"/2019/08/12/Spring-2019-08-Spring源码初探/"},{"title":"设计模式（六）：原型模式","text":"原型模式简介 原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 调用者不需要知道任何创建细节 属于创建型模式 使用场景 类初始化小号资源较多 new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等） 构造函数比较复杂 循环体中产生大量对象时 常见原型模式工具类1BeanUtil.copy(); 1JSON.paseObject(); 1Guava 利用Java提供的Cloneable接口实现浅克隆123456public Object shallowClone(Test target){ Test test = new Test(); test.a = target.a;//普通字段 test.object = target.object;//对象字段，拷贝的是引用地址 return test;} 深克隆1234567891011121314151617181920public Object deepClone(){ try{ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); QiTianDaSheng copy = (QiTianDaSheng)ois.readObject(); copy.birthday = new Date(); return copy; }catch (Exception e){ e.printStackTrace(); return null; }finally{ ...close; }} 深克隆例子1ArrayList.clone();//ArrayList重写了clone方法","link":"/2019/08/08/design-2019-08-设计模式（六）：原型模式/"},{"title":"Linux学习（三）：管道和链接","text":"管道和链接1.|管道 ls -l / | more 一个命令的输出可以通过管道交给另一个命令的输出 2.ln链接 软链接：软链接不占用磁盘空间，源文件删除则软链接失效。 ln -s 源文件 链接文件 注意：如果软链接文件和源文件不在统一目录，源文件要使用绝对路径，不能使用相对路径，因为软链接只会记录路径名称。 硬链接：硬链接只能链接普通文件，不能链接目录。本身占用空间，与源文件同步发生变化，使用ll查看文件时，有一个数字，代表有几个文件能同步发生变化。 ln 源文件 链接文件","link":"/2019/05/06/linux-2019-05-Linux学习（三）：管道和链接/"},{"title":"Linux学习（二）：权限及通配符","text":"ls 查看权限执行touch a 新建文件a,执行命令 ll -h查看列表文件a的详细信息（下面用作例子详细介绍） -rw-rw-r–. 1 test test 0 1月 4 11:11 a 解读\\列名 权限 硬件链接数 文件属主 文件所属的组 文件大小 文件修改时间 文件名 信息 -rw-rw-r–. 1 test test 0 1月 4 11:11 a 详解1 第一个字符[-d]，d代表文件夹，-代表文件 - - - - - - 详解2 第一个字符后9个字符分为三组[-rwx][-rwx][-rwx]。r代表可读，w代表可写，x代表可执行-代表非。 - - - - - - 详解3 三组[-rwx][-rwx][-rwx]中。第一组：当前用户的权限，第二组：当前用户组对文件的权限，第三组：其他用户组的权限 - - - - - - 文件夹ceshi的详细信息 drwxrwxr-x. 2 test test 6 1月 4 11:10 ceshi chmod设置权限1.chmod字母法 语 法： chmod [ugoa] [+-=] [rwx] 文件demo：chmod u+x test.txt 给文件拥有者添加可执行权限 u:user表示文件所有者 g：group 表示文件所有者属于同一组（group）者，即用户组 o：other表示其他人 a：All 表示所有人 +：增加权限 -：撤销权限 =：设定权限 r：red 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容 w：write表示可写入，对于一个目录，如果没有w权限，那么就意味着不能再目录下创建文件 x：excute 表示可执行，对于一个目录，如果没有x权限，就意味着不能通过cd进入这个目录。 2.chmod数字法 语 法：chmod [124][124][124] 文件 数字 说明 4 r 读取权限 2 w 写入权限 1 x 执行权限 0 - 不具任何权限 demo：chmod 123 a.txt 第一位数字代表自己的权限 第二位数字代表自己组的权限 第三位数字代表其他人的权限 3 =1+2 代表w+x 通配符 通配符 含义 * 代表文件名中所有字符 ls te* 查找以te开头的文件 ls *html 查找html结尾的文件 ？ 代表文件名任意一个字符 ls ?.c 只找第一个字符任意，后缀为.c的文件 [abc] 匹配abc中任意一个 [a-f] 匹配从a到f 范围内的任意一个字符 ls [a-f]* 找到从a到f范围内的任意一个字符开头的文件 ls a-f 找到名字为a-f的文件，当-处于[]之外失去通配符的作用 \\ 转义字符","link":"/2019/05/06/linux-2019-05-Linux学习（二）：权限及通配符/"},{"title":"Linux学习（一）：命令基本使用","text":"常用Linux命令的基本使用1.cd 切换文件夹（change directory） cd /home绝对路径，以根目录开头 cd admin相对路径，不以根目录开头 cd .. 返回上一级目录 cd ~ 到自己家的目录（/home/admin） cd - 在当前目录和最近的一个历史操作目录切换 2.pwd 查看当前目录所在路径（print wrok directory）3.ls 查看当前目录内容（list） ls -l 显示详细列表 ls -lh 把文件大小以人性化的方式显示 ls -a 显示所有文件，包含隐藏文件，隐藏文件是.开头的文件 ll 等于ls -l 命令可组合使用，比如ll -a 、ls -hla。 -后面的关键词顺序不固定 4.mkdir 创建目录（make directory） mkdir test 在当前目录创建文件夹取名“test” mkdir /home/admin/test 在绝对路径创建文件夹 mkdir /home/admin/a/test -p 如果上级目录不存在，加上-p自动创建目录 mkdir test1 test2 在当前目录创建多个文件夹 mkdir a/{b,c} 在指定目录下创建多个文件夹 mkdir .test 以.开头创建隐藏文件夹 每个目录下都有.、.. 两个隐藏目录 5.touch 如果文件不存在，新建文件（touch） touch abc.txt 在当前目录下创建，如果指定了目录，必须保证上级目录存在 touch .abc 创建隐藏文件 gedit abc.txt 打开文件进行编辑，如果文件不存在则创建文件 6.rm 删除指定文件名（remove） rm a.txt 删除文件 rm abc -r 删除文件夹 rm * -r 删除所有文件和文件夹（不能删除隐藏文件） 7.clear 清屏（clear）8.cp 拷贝文件（copy） cp a.txt b.txt 拷贝源文件a.txt到目标文件b.txt cp abc abc_bak -r 拷贝文件夹 cp选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 不常用，默认会加上。覆盖已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 9.mv 移动/剪切、重命名（move） mv a.txt a 剪切a.txt到a文件夹下，如果要改名字修改后者路径即可 mv选项 含义 -f 禁止交互式操作，如果覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问用户回答以避免误覆盖文件 -v 显示移动进度 注意：mv对文件夹可以直接移动，不需要-r 10.&gt; 重定向 ls &gt; 1.txt 把ls命令返回的结果输出到文件中，会覆盖之前的数据，默认情况ls的返回结果是显示在屏幕中 ls&gt;&gt;1.txt把ls命令返回的结果输出到1.txt中，以追加的方式。 11.cat查看文件内容 cat 1.txt 把文件的内容全部显示到屏幕中 cat 1.txt 2.txt 把两个文件内容全部显示到屏幕中 cat 1.txt 2.txt &gt;3.txt把多个文件的内容合并到新的文件中 12.more查看文件内容，可以分页显示 more 1.txt 查看内容多的文件，按空格键往下翻页，按b键往回翻页，按enter下一行，按q键退出","link":"/2019/05/06/linux-2019-05-Linux学习（一）：命令基本使用/"},{"title":"初识Spring-IOC、DI","text":"初识Spring IOC 、DI、AOPIOC(Inversion of Control)控制反转所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。 常用注解 @Component ：组件通用注解，常用于Model类 @Controller ：常用于对Controller实现类进行标注 @Service：常用于对Service实现类进行标注 @Repository：常用于对DAO实现类进行标注 DI(Dependency Injection)依赖注入指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。 常用注解 @Value ：注入普通类型属性 @Resource ：注入对象类型 @Autowired ：注入对象类型，默认按照类型注入。结合@Qualifier注解完成按名称的注入。 Aop(aspect object programming)面向切面编程AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向切面编程。可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP设计模式孜孜不倦追求的是调用者和被调用者之间的解耦，AOP 可以说也是这种目标的一种实现。我们现在做的一些非业务，如：日志、事务、安全等都会写在业务代码中(也即是说，这些非业务类横切于业务类)，但这些代码往往是重复，复制——粘贴式的代码会给程序的维护带来不便, AOP 就实现了把这些业务需求与系统需求分开来做。这种解决的方式也称代理机制。 AOP 中必须明白的几个概念 切面（Aspect） 官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。“切面”在ApplicationContext 中aop:aspect来配置。 连接点（Joinpoint） 程序执行过程中的某一行为，例如，MemberService .get 的调用或者 MemberService .delete 抛出异常等行为。 通知（Advice） “切面”对于某个“连接点”所产生的动作。其中，一个“切面”可以包含多个“Advice”。 切入点（Pointcut） 匹配连接点的断言，在 AOP 中通知和一个切入点表达式关联。切面中的所有通知所关注的连接点，都由切入点表达式来决定。 目标对象（Target Object） 被一个或者多个切面所通知的对象。例如，AServcieImpl 和 BServiceImpl，当然在实际运行时，Spring AOP 采用代理实现，实际 AOP 操作的是 TargetObject 的代理对象。 AOP 代理（AOP Proxy） 在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLib 代理。默认情况下，TargetObjec实现了接口时，则采用 JDK 动态代理，例如，AServiceImpl；反之，采用 CGLib 代理，例如，BServiceImpl。 强制使用 CGLib 代理需要将 aop:config的 proxy-target-class 属性设为 true。 通知类型 前置通知（Before Advice） 在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在aop:aspect里面使用aop:before元素进行声明。例如，TestAspect 中的 doBefore 方法。 后置通知（After Advice） 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在 aop:aspect里面使用aop:after元素进行声明。例如，ServiceAspect 中的 returnAfter 方法，所 以 Teser 中调用 UserService.delete 抛出异常时，returnAfter 方法仍然执行。 返回后通知（After Return Advice） 在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在aop:aspect 里面使用元素进行声明。 环绕通知（Around Advice） 包围一个连接点的通知，类似 Web 中 Servlet 规范中的 Filter 的 doFilter 方法。可以在方法的调用前 后完成自定义的行为，也可以选择不执行。ApplicationContext 中在aop:aspect里面使用 aop:around元素进行声明。例如，ServiceAspect 中的 around 方法。 异常通知（After Throwing Advice） 在 方 法 抛 出 异 常 退 出 时 执 行 的 通 知 。 ApplicationContext 中 在 aop:aspect 里 面 使 用 aop:after-throwing元素进行声明。例如，ServiceAspect 中的 returnThrow 方法。 注：可以将多个通知应用到一个目标对象上，即可以将多个切面织入到同一目标对象。 基于XML的注入方式1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\"?&gt;&lt;beans xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns=\"http://www.springframework.org/schema/beans\"&gt; &lt;!-- 注解驱动加上这句话 --&gt; &lt;!--&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;--&gt; &lt;bean class=\"com.xxx.xxx.aop.aspect.XmlAspect\" id=\"xmlAspect\"/&gt; &lt;!--AOP配置 --&gt; &lt;aop:config&gt; &lt;!--声明一个切面,并注入切面Bean,相当于@Aspect --&gt; &lt;aop:aspect ref=\"xmlAspect\"&gt; &lt;!--配置一个切入点,相当于@Pointcut --&gt; &lt;aop:pointcut id=\"simplePointcut\" expression=\"execution(* com.xxx.xxx.aop.service..*(..))\"/&gt; &lt;!--配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt; &lt;aop:before method=\"before\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after-returning method=\"afterReturn\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after-throwing method=\"afterThrow\" pointcut-ref=\"simplePointcut\" throwing=\"ex\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"simplePointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 基于注解的AOP12345678910111213141516171819202122232425262728293031//声明这是一个组件@Component//声明这是一个切面Bean@Aspectpublic class ArgsAspect { private final static Logger log = Logger.getLogger(ArgsAspect.class); //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点 @Pointcut(\"execution(* com.xxx.xxx.aop.service..*(..))\") public void aspect(){ } //配置前置通知,拦截返回值为com.xxx.xxx.model.Member的方法 @Before(\"execution(com.xxx.xxx.model.Member com.gupaoedu.vip.aop.service..*(..))\") public void beforeReturnUser(JoinPoint joinPoint){ log.info(\"beforeReturnUser \" + joinPoint); } //配置前置通知,拦截参数为com.xxx.xxx.model.Member的方法 @Before(\"execution(* com.xxx.xxx.aop.service..*(com.xxx.xxx.model.Member))\") public void beforeArgUser(JoinPoint joinPoint){ log.info(\"beforeArgUser \" + joinPoint); } //配置前置通知,拦截含有long类型参数的方法,并将参数值注入到当前方法的形参id中 @Before(\"aspect()&amp;&amp;args(id)\") public void beforeArgId(JoinPoint joinPoint, long id){ log.info(\"beforeArgId \" + joinPoint + \"\\tID:\" + id); } } 附: 基于注解开发的细节 引入约束 1234567&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 开启注解扫描 12&lt;context:component-scan base-package=\"com.xxx.xxx\"/&gt;&lt;context:annotation-config /&gt; 其他附加属性 @Scope ：在类上添加的，控制类生成的时候采用单例还是多例。取值： singleton ：单例prototype ：多例request ：request域，需要在web环境session ：session域，需要在web环境application： context域，需要在web环境globalsession 集群环境的session域，需要在web环境 @PostConstruct ：Bean生命周期中的初始化阶段执行,相当于init-method @PreDestroy ：Bean生命周期中的销毁阶段执行,相当于destroy-method","link":"/2019/08/21/Spring-2019-08-初识Spring-IOC、DI、AOP/"},{"title":"Linux学习（五）：文件解压缩","text":"文件解压缩tar 归档 打包 打包 tar cvf a.tar 1.txt 2.txt ：f必须放到最后，f后面的第一个参数代表要生成的文件名，后面所有的参数是要打包的文件 tar tf a.tar ： 列出包里面的文件 解包 tar xvf a.tar 如果没有写目录，把包里面的文件解开放到当前目录 tar xvf a.tar -C tar 解压到指定文件夹，文件夹需要提前创建好 gzip 压缩文件 生成压缩文件 ① 打包tar cf a.tar * 生成a.tar② 压缩gzip -r a.tar 生成a.tar.gz文件 解压压缩文件 ① 解压gzip -d a.tar.gz 生成a.tar② 解包tar xf a.tar -C ~/atar 解包到指定文件夹中 一步到位打包并且压缩tar czf b.tar.gz *.txt 以gzip的方式打包并且压缩 一步到位解压并且解包tar zxf b.tar.gz -C btar 以gzip的方式解压缩并且解包 bzip2 压缩文件（用法同gzip） 压缩 tar jcf j.tar.bz2 *.txt 压缩文件 解压 tar xjf j.tar.bz2 -C jtar 解压文件 zip 压缩文件 压缩 zip -r zz *.txt zz 代表要生成的压缩文件，不需要写扩展名，会自动生成zip扩展名 解压 uzip -d zz zz.zip 解压时会自动创建目录 压缩率 zip&lt;gzip&lt;bzip2 通用性 zip&gt;gzip&gt;bzip2综合考虑：linux系统中一般使用gzip","link":"/2019/05/06/linux-2019-05-Linux学习（五）：文件解压缩/"},{"title":"Linux学习（六）：其他命令","text":"which 查看命令位置 which zip 查看zip命令的可执行文件所在位置，但无法查找cd这样的shell类型命令。 su 切换账号 su Centos下切换到root用户命令su test 切换到test用户 root切换其他用户不用输入密码，反之要输入密码。 passwd 重置密码 passwd 修改当前用户密码，密码有复杂度要求passwd test 切换到root后执行该命令，修改test用户密码，无强制要求密码复杂度 exit 退出当前用户 注意：如果使用su 登录root后再使用exit 只是退出root，当前窗口不会关闭。 who 查看当前登录的客户端，或者当前登录的命令终端 “pts”代表终端“tty”代表用户登录了操作系统pkill -kill -t tty1 杀死一个客户端连接 reboot、shutdown 重启、关机 命令 含义 reboot 重新启动操作系统 shutdown -r now 重启操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now代表时间为0的状态 shutdown -h 20:35 系统在今天的20:35会关机 shutdown -h +10 系统在十分钟之后自动关机 ，要取消则按ctrl+c","link":"/2019/05/06/linux-2019-05-Linux学习（六）：其他命令/"},{"title":"Linux学习（四）：四剑客之二（grep、find）","text":"linux四剑客grep 查找文件内容 grep hello test.txt 在某个文件中查找包含hello的内容，只要一行中有hello会把整行显示 grep -niv helle test.txt n显示查找到的内容行号，i查找时不区分大小写，v反向查找（查找不包含hello的行） grep -n hello home/admin -r 查找整个目录中的所有文件，包含hello的内容 find 查找文件 find /home -name 1.txt 在/home目录下查找文件名为1.txt的文件，输出文件路径 find /home -name '*.txt'在/home目录下查找所有后缀为.txt的文件。注意：如果查找模糊文件名，需对文件名参数加上引号。","link":"/2019/05/06/linux-2019-05-Linux学习（四）：四剑客之二（grep、find）/"},{"title":"渐入Spring-IOC","text":"渐入Spring-IOC一、IOC Spring核心容器类图 BeanFactory Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下： 其中 BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，它实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表化的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。最基本的 IOC 容器接口 BeanFactory，来看一下它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.springframework.beans.factory;import org.springframework.beans.BeansException;import org.springframework.core.ResolvableType;import org.springframework.lang.Nullable;public interface BeanFactory { //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，如果需要得到工厂本身，需要转义 String FACTORY_BEAN_PREFIX = \"&amp;\"; //根据bean的名字，获取在IOC容器中得到bean实例 Object getBean(String name) throws BeansException; //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。 &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; //提供对bean的检索，看看是否在IOC容器有这个名字的bean boolean containsBean(String name); //根据bean名字得到bean实例，并同时判断这个bean是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; //得到bean实例的Class类型 @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来 String[] getAliases(String name);} 在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 Bean 是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的实现 。 比如 GenericApplicationContext ， ClasspathXmlApplicationContext 等 。ApplicationContext 是 Spring 提供的一个高级的 IOC 容器，它除了能够提供 IOC 容器的基本功能外，还为用户提供了以下的附加服务。 从 ApplicationContext 接口的实现，我们看出其特点： 1、支持信息源，可以实现国际化。（实现 MessageSource 接口）2、访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到)3、支持应用事件。(实现 ApplicationEventPublisher 接口) BeanDefinition SpringIOC 容器管理了我们定义的各种 Bean 对象及其相互的关系，Bean 对象在 Spring 实现中是以 BeanDefinition 来描述的，其继承体系如下： BeanDefinitionReader Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，最后看看 Spring 中 BeanDefinitionReader的类结构图： 延伸–寻找Web IOC入口 以DispatcherServlet为例, DispatcherServlet继承&gt;HttpServletBean执行init()方法如下: 1234567891011121314151617181920212223242526272829303132public final void init() throws ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); } // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { //定位资源 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); //加载配置信息 ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); } throw ex; } } // Let subclasses do whatever initialization they like. initServletBean(); if (logger.isDebugEnabled()) { logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); } } 在 init()方法中，真正完成初始化容器动作的逻辑其实在 initServletBean()方法中，这是个钩子方法, 我们继续跟进initServletBean()中的代码在 FrameworkServlet 类中： 12345678910111213141516171819202122232425262728@Override protected final void initServletBean() throws ServletException { getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) { this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); } long startTime = System.currentTimeMillis(); try { this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } catch (RuntimeException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); } } 继续跟进 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162protected WebApplicationContext initWebApplicationContext() { //先从ServletContext中获得父容器WebAppliationContext WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); //声明子容器 WebApplicationContext wac = null; //建立父、子容器之间的关联关系 if (this.webApplicationContext != null) { // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } //这个方法里面调用了AbatractApplication的refresh()方法 //模板方法，规定IOC初始化基本流程 configureAndRefreshWebApplicationContext(cwac); } } } //先去ServletContext中查找Web容器的引用是否存在，并创建好默认的空IOC容器 if (wac == null) { // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } //给上一步创建好的IOC容器赋值 if (wac == null) { // No context instance is defined for this servlet -&gt; create a local one wac = createWebApplicationContext(rootContext); } //触发onRefresh方法 if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. onRefresh(wac); } if (this.publishContext) { // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() + \"' as ServletContext attribute with name [\" + attrName + \"]\"); } } return wac; } 在 configAndRefreshWebApplicationContext()方法中，调用 refresh()方法，这个是真正启动 IOC 容器的入口，后面会详细介绍。IOC 容器初始化以后，最后调用了DispatcherServlet 的 onRefresh()方法，onRefresh()是为DispatcherServlet提供的钩子方法,在 onRefresh()方法中又是直接调用 initStrategies()方法初始化 SpringMVC 的九大组件： 123456789101112131415161718192021222324252627public class DispatcherServlet extends FrameworkServlet { //DispatcherServlet protected void onRefresh(ApplicationContext context) { initStrategies(context); } //初始化策略 protected void initStrategies(ApplicationContext context) { //多文件上传的组件 initMultipartResolver(context); //初始化本地语言环境 initLocaleResolver(context); //初始化模板处理器 initThemeResolver(context); //handlerMapping initHandlerMappings(context); //初始化参数适配器 initHandlerAdapters(context); //初始化异常拦截器 initHandlerExceptionResolvers(context); //初始化视图预处理器 initRequestToViewNameTranslator(context); //初始化视图转换器 initViewResolvers(context); // initFlashMapManager(context); }} 基于XML的IOC容器初始化原理IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、加载和注册这三个基本的过程。我们以ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示： ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring应用提供了一个共享的 Bean 定义环境。 寻找入口 我们用的比较多的 ClassPathXmlApplicationContext，通过 main()方法启动: 1ApplicationContext app = new ClassPathXmlApplicationContext(\"application.xml\"); 先看其构造函数的调用： 123public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[]{configLocation}, true, (ApplicationContext)null);} 其实际调用的构造函数为： 1234567public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); this.setConfigLocations(configLocations); if(refresh) { this.refresh(); }} 还有像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、XmlWebApplicationContext等都继承自父容器AbstractApplicationContext主要用到了装饰器模式和策略模式，最终都是调用 refresh()方法。 获得配置路径 通过分析ClassPathXmlApplicationContext的源代码可以知道, 在创建ClassPathXmlApplicationContext容器时, 构造方法做了两项重要工作:首先, 调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器. 然后, 再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置 Bean 配置信息的定位路径. 通过追踪ClassPathXmlApplicationContext的继承体系, 发现其超类AbstractApplicationContext中初始化IOC容器所得的主要源码如下: 1234567891011121314151617181920212223public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { //静态初始化块，在整个容器创建过程中只执行一次 static { //为了避免应用程序在 Weblogic8.1 关闭时出现类加载异常加载问题，加载 IOC 容 //器关闭事件(ContextClosedEvent)类 ContextClosedEvent.class.getName(); } public AbstractApplicationContext() { this.resourcePatternResolver = getResourcePatternResolver(); } public AbstractApplicationContext(@Nullable ApplicationContext parent) { this(); setParent(parent); } //获取一个 Spring Source 的加载器用于读入 Spring Bean 配置信息 protected ResourcePatternResolver getResourcePatternResolver() { //AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器 //Spring 资源加载器，其 getResource(String location)方法用于载入资源 return new PathMatchingResourcePatternResolver(this); }...} AbstractApplicationContext 的默认构造方法中有调用 PathMatchingResourcePatternResolver 的构造方法创建 Spring 资源加载器： 12345public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) { Assert.notNull(resourceLoader, \"ResourceLoader must not be null\"); //设置 Spring 的资源加载器 this.resourceLoader = resourceLoader;} 在设置容器的资源加载器之后，接下来 ClassPathXmlApplicationContext 执行setConfigLocations()方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean配置信息的定位，该方法的源码如下： 12345678910111213141516171819202122232425//处理单个资源文件路径为一个字符串的情况public void setConfigLocation(String location) { //String CONFIG_LOCATION_DELIMITERS = \",; /t/n\"; //即多个资源文件路径之间用” ,; \\t\\n”分隔，解析成数组形式 setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));} /** * Set the config locations for this application context. * &lt;p&gt;If not set, the implementation may use a default as appropriate. *///解析Bean定义资源文件的路径，处理多个资源文件字符串数组public void setConfigLocations(@Nullable String... locations) { if (locations != null) { Assert.noNullElements(locations, \"Config locations must not be null\"); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) { // resolvePath为同一个类中将字符串解析为路径的方法 this.configLocations[i] = resolvePath(locations[i]).trim(); } } else { this.configLocations = null; }} 通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 配置信息，也可以使用字符串数组，即下面两种方式都是可以的： 1234//法1ClassPathResource res = new ClassPathResource(\"a.xml,b.xml\");//法2ClassPathResource res =new ClassPathResource(new String[]{\"a.xml\",\"b.xml\"}); 开始启动 SpringIOC 容器对 Bean 配置资源的载入是从refresh()函数开始的，refresh()是一个模板方法，规定了IOC容器的启动流程 ， 有些逻辑要交给其子类去实 现 。它对 Bean配置资源进行载入ClassPathXmlApplicationContext 通过调用其父类AbstractApplicationContext 的 refresh()函数启动整个 IOC 容器对 Bean 定义的载入过程，现在我们来详细看看 refresh()中的逻辑处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. //1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //3、为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. //4、为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //5、调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //6、为BeanFactory注册BeanPost事件处理器. //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //7、初始化信息源，和国际化相关. initMessageSource(); // Initialize event multicaster for this context. //8、初始化容器事件传播器. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //9、调用子类的某些特殊Bean初始化方法 onRefresh(); // Check for listener beans and register them. //10、为事件传播器注册事件监听器. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //11、初始化所有剩余的单例Bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. //13、销毁已创建的Bean destroyBeans(); // Reset 'active' flag. //14、取消refresh操作，重置容器的同步标识。 cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... //15、重设公共缓存 resetCommonCaches(); } } } refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 配置信息从其子类容器的refreshBeanFactory()方法启动, 所以整个refresh()中 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();这句以后代码都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。 refresh()方法的主要作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。它类似于对 IOC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 配置资源进行载入。 创建容器 obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入 Bean 配置信息的过程，代码如下： 12345678910protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { //这里使用了委派设计模式，父类定义了抽象的 refreshBeanFactory()方法，具体实现调用子类容器的 refreshBeanFactory()方 法 refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) { logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); } return beanFactory;} AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是其子类 AbstractRefreshableApplicationContext 实现的 refreshBeanFactory()方法，方法的源码如下： 12345678910111213141516171819202122protected final void refreshBeanFactory() throws BeansException { //如果已经有容器，销毁容器中的bean，关闭容器 if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { //创建IOC容器 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); //对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等 customizeBeanFactory(beanFactory); //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } 在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载 bean 定义。 载入配置路径 AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext的主要源码如下：loadBeanDefinitions()方法同样是抽象方法, 是由其子类实现的, 也即在AbstractXmlApplicationContext 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {... //实现父类抽象的载入 Bean 定义方法 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { //创建 XmlBeanDefinitionReader，即创建 Bean 读取器，并通过回调设置到容器中去，容器使用该读取器读取 Bean 配置资源 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); //为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的 //祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); //为 Bean 读取器设置 SAX xml 解析器 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); //当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制 initBeanDefinitionReader(beanDefinitionReader); //Bean 读取器真正实现加载的方法 loadBeanDefinitions(beanDefinitionReader); } protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) { reader.setValidating(this.validating); } //Xml Bean 读取器加载 Bean 配置资源 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { //获取 Bean 配置资源的定位 Resource[] configResources = getConfigResources(); if (configResources != null) { //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源 reader.loadBeanDefinitions(configResources); } // 如果子类中获取的 Bean 配置资源定位为空，则获取 ClassPathXmlApplicationContext // 构造方法中 setConfigLocations 方法设置的资源 String[] configLocations = getConfigLocations(); if (configLocations != null) { //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源 reader.loadBeanDefinitions(configLocations); } } //这里又使用了一个委托模式，调用子类的获取 Bean 配置资源定位的方法 //该方法在 ClassPathXmlApplicationContext 中进行实现，对于我们 //举例分析源码的 ClassPathXmlApplicationContext 没有使用该方法 @Nullable protected Resource[] getConfigResources() { return null; }} 以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。由于我们使用 ClassPathXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。 分配路径处理策略 在 XmlBeanDefinitionReader 的抽象父类 AbstractBeanDefinitionReader 中定义了载入过程。AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法@Overridepublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException { return loadBeanDefinitions(location, null);}public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException { //获取在IoC容器初始化过程中设置的资源加载器 ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException( \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\"); } if (resourceLoader instanceof ResourcePatternResolver) { // Resource pattern matching available. try { //将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源 //加载多个指定位置的Bean定义资源文件 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resources); if (actualResources != null) { for (Resource resource : resources) { actualResources.add(resource); } } if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\"); } return loadCount; } catch (IOException ex) { throw new BeanDefinitionStoreException( \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex); } } else { // Can only load single resources by absolute URL. //将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源 //加载单个指定位置的Bean定义资源文件 Resource resource = resourceLoader.getResource(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resource); if (actualResources != null) { actualResources.add(resource); } if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\"); } return loadCount; }} //重载方法，调用loadBeanDefinitions(String);@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \"Location array must not be null\"); int counter = 0; for (String location : locations) { counter += loadBeanDefinitions(location); } return counter;} AbstractRefreshableConfigApplicationContext 的 loadBeanDefinitions(Resource...resources) 方法实际上是调用 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法。从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码分析可以看出该方法就做了两件事：首先，调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在loadBeanDefinitions()方法中调用了 AbstractApplicationContext 的 getResources()方法，跟进去之后发现getResources()方法其实定义在 ResourcePatternResolver 中，此时，我们有必要来看一下ResourcePatternResolver 的全类图： 从上面可以看到 ResourceLoader 与 ApplicationContext 的继承关系，可以看出其实际调用的是DefaultResourceLoader中的getSource() 方法定位 Resource ，因为ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了ClassPathXmlApplicationContext 中来。 解析配置文件路径 XmlBeanDefinitionReader通过配置文件ClassPathXmlApplicationContext的父类DefaultResourceLoader的 getResource()方法获取要加载的资源，其源码如下 123456789101112131415161718192021222324252627282930313233//获取Resource的具体实现方法 @Override public Resource getResource(String location) { Assert.notNull(location, \"Location must not be null\"); for (ProtocolResolver protocolResolver : this.protocolResolvers) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } //如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象 if (location.startsWith(\"/\")) { return getResourceByPath(location); } else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // Try to parse the location as a URL... // 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象 URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&gt; resolve as resource path. //如果既不是classpath标识，又不是URL标识的Resource定位，则调用 //容器本身的getResourceByPath方法获取Resource return getResourceByPath(location); } } } DefaultResourceLoader 提供了 getResourceByPath()方法的实现，就是为了处理既不是 classpath标识，又不是 URL 标识的 Resource 定位这种情况。 123protected Resource getResourceByPath(String path) {return new ClassPathContextResource(path, getClassLoader());} 在 ClassPathResource 中完成了对整个路径的解析。这样，就可以从类路径上对 IOC 配置文件进行加载，当然我们可以按照这个逻辑从任何地方加载，在 Spring 中我们看到它提供的各种资源抽象，比如ClassPathResource、URLResource、FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分。例如 FileSystemXmlApplication 容器就重写了getResourceByPath()方法： 12345678@Overrideprotected Resource getResourceByPath(String path) { if (path.startsWith(\"/\")) { path = path.substring(1); } //这里使用文件系统资源对象来定义 bean 文件 return new FileSystemResource(path);} 通过子类的覆盖，巧妙地完成了将类路径变为文件路径的转换。 开始读取配置内容 继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文件的资源定义以后的载入过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//XmlBeanDefinitionReader加载资源的入口方法@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { //将读入的XML资源进行特殊编码处理 return loadBeanDefinitions(new EncodedResource(resource));}//这里是载入XML形式Bean定义资源文件方法public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) { logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); } Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); } try { //将资源文件转为InputStream的IO流 InputStream inputStream = encodedResource.getResource().getInputStream(); try { //从InputStream中得到XML的解析源 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //这里是具体的读取过程 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { //关闭从Resource中得到的IO流 inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }} 载入 Bean 配置信息的最后一步是将 Bean 配置信息转换为 Document 对象，该过程由documentLoader()方法实现。 准备文档对象 DocumentLoader 将 Bean 配置资源转换成 Document 对象的源码如下： 123456789101112131415161718public class DefaultDocumentLoader implements DocumentLoader { ... //使用标准的JAXP将载入的Bean定义资源转换成document对象 @Override public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception { //创建文件解析器工厂 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) { logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\"); } //创建文档解析器 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); //解析Spring的Bean定义资源 return builder.parse(inputSource); }} 上面的解析过程是调用 JavaEE 标准的 JAXP 标准进行处理。至此 Spring IOC 容器根据定位的 Bean 配置信息，将其加载读入并转换成为 Document 对象过程完成。接下来我们要继续分析 Spring IOC 容器将载入的 Bean 配置信息转换为 Document 对象之后，是如何将其解析为Spring IOC 管理的 Bean 对象并将其注册到容器中的。 分配解析策略 XmlBeanDefinitionReader 类中的 doLoadBeanDefinition()方法是从特定 XML 文件中实际载入Bean 配置资源的方法，该方法在载入 Bean 配置资源之后将其转换为 Document 对象，接下来调用registerBeanDefinitions() 启 动 Spring IOC 容 器 对 Bean定义的解析过程，registerBeanDefinitions()方法源码如下： 123456789101112//按照 Spring 的 Bean 语义要求将 Bean 配置资源解析并转换为容器内部数据结构public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { //得到 BeanDefinitionDocumentReader 来对 xml 格式的 BeanDefinition 解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获得容器中注册的 Bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader 只是个接口, //具体的解析实现过程有实现类 DefaultBeanDefinitionDocumentReader 完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //统计解析的 Bean 数量 return getRegistry().getBeanDefinitionCount() - countBefore;} Bean 配置资源的载入解析分为以下两个过程： 首先，通过调用 XML 解析器将 Bean 配置信息转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程. 其次，在完成通用的 XML 解析之后，按照 Spring Bean 的定义规则对 Document 对象进行解析，其解析过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的 将配置载入内存 BeanDefinitionDocumentReader 接 口 通 过 registerBeanDefinitions() 方 法 调 用 其 实现类DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248 //根据Spring DTD对Bean的定义规则解析Bean定义Document对象 @Override public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { //获得XML描述符 this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); //获得Document的根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root); }protected void doRegisterBeanDefinitions(Element root) { //具体的解析过程由BeanDefinitionParserDelegate实现， //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性 preProcessXml(root); //从Document的根元素开始进行Bean定义的Document对象 parseBeanDefinitions(root, this.delegate); //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性 postProcessXml(root); this.delegate = parent; } //创建BeanDefinitionParserDelegate，用于完成真正的解析过程 protected BeanDefinitionParserDelegate createDelegate( XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) { BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); //BeanDefinitionParserDelegate初始化Document根元素 delegate.initDefaults(root, parentDelegate); return delegate; } //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { //Bean定义的Document对象使用了Spring默认的XML命名空间 if (delegate.isDefaultNamespace(root)) { //获取Bean定义的Document对象根元素的所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //获得Document节点是XML元素节点 if (node instanceof Element) { Element ele = (Element) node; //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间 if (delegate.isDefaultNamespace(ele)) { //使用Spring的Bean规则解析元素节点 parseDefaultElement(ele, delegate); } else { //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点 delegate.parseCustomElement(ele); } } } } else { //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的 //解析规则解析Document根节点 delegate.parseCustomElement(root); } } //使用Spring的Bean规则解析Document元素节点 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { //如果元素节点是&lt;Import&gt;导入元素，进行导入解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } //如果元素节点是&lt;Alias&gt;别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } //元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素， //按照Spring的Bean规则解析元素 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } /** * Parse an \"import\" element and load the bean definitions * from the given resource into the bean factory. */ //解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中 protected void importBeanDefinitionResource(Element ele) { //获取给定的导入元素的location属性 String location = ele.getAttribute(RESOURCE_ATTRIBUTE); //如果导入元素的location属性值为空，则没有导入任何资源，直接返回 if (!StringUtils.hasText(location)) { getReaderContext().error(\"Resource location must not be empty\", ele); return; } // Resolve system properties: e.g. \"${user.dir}\" //使用系统变量值解析location属性值 location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location); Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4); // Discover whether the location is an absolute or relative URI //标识给定的导入元素的location是否是绝对路径 boolean absoluteLocation = false; try { absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); } catch (URISyntaxException ex) { // cannot convert to an URI, considering the location relative // unless it is the well-known Spring prefix \"classpath*:\" //给定的导入元素的location不是绝对路径 } // Absolute or relative? //给定的导入元素的location是绝对路径 if (absoluteLocation) { try { //使用资源读入器加载给定路径的Bean定义资源 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isDebugEnabled()) { logger.debug(\"Imported \" + importCount + \" bean definitions from URL location [\" + location + \"]\"); } } catch (BeanDefinitionStoreException ex) { getReaderContext().error( \"Failed to import bean definitions from URL location [\" + location + \"]\", ele, ex); } } else { // No URL -&gt; considering resource location as relative to the current file. //给定的导入元素的location是相对路径 try { int importCount; //将给定导入元素的location封装为相对路径资源 Resource relativeResource = getReaderContext().getResource().createRelative(location); //封装的相对路径资源存在 if (relativeResource.exists()) { //使用资源读入器加载Bean定义资源 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); } //封装的相对路径资源不存在 else { //获取Spring IOC容器资源读入器的基本路径 String baseLocation = getReaderContext().getResource().getURL().toString(); //根据Spring IOC容器资源读入器的基本路径加载给定导入路径的资源 importCount = getReaderContext().getReader().loadBeanDefinitions( StringUtils.applyRelativePath(baseLocation, location), actualResources); } if (logger.isDebugEnabled()) { logger.debug(\"Imported \" + importCount + \" bean definitions from relative location [\" + location + \"]\"); } } catch (IOException ex) { getReaderContext().error(\"Failed to resolve current resource location\", ele, ex); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to import bean definitions from relative location [\" + location + \"]\", ele, ex); } } Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]); //在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); } /** * Process the given alias element, registering the alias with the registry. */ //解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名 protected void processAliasRegistration(Element ele) { //获取&lt;Alias&gt;别名元素中name的属性值 String name = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Alias&gt;别名元素中alias的属性值 String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; //&lt;alias&gt;别名元素的name属性值为空 if (!StringUtils.hasText(name)) { getReaderContext().error(\"Name must not be empty\", ele); valid = false; } //&lt;alias&gt;别名元素的alias属性值为空 if (!StringUtils.hasText(alias)) { getReaderContext().error(\"Alias must not be empty\", ele); valid = false; } if (valid) { try { //向容器的资源读入器注册别名 getReaderContext().getRegistry().registerAlias(name, alias); } catch (Exception ex) { getReaderContext().error(\"Failed to register alias '\" + alias + \"' for bean with name '\" + name + \"'\", ele, ex); } //在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); } } /** * Process the given bean element, parsing the bean definition * and registering it with the registry. */ //解析Bean定义资源Document对象的普通元素 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类 //对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现 // BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. //向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. //在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 通过上述 Spring IOC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在Spring 配置文件中可以使用&lt;import&gt;元素来导入 IOC 容器所需要的其他资源，Spring IOC 容器在解析时会首先将指定导入的资源加载进容器中。使用&lt;ailas&gt;别名时，Spring IOC 容器首先将别名元素所定义的别名注册到容器中。对于既不是&lt;import&gt;元素，又不是&lt;alias&gt;元素的元素，即 Spring 配置文件中普通的&lt;bean&gt;元素的解析由BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement()方法来实现。 载入&lt;bean&gt;元素 Bean 配置信息中的&lt;import&gt;和&lt;alias&gt;元素解析在 DefaultBeanDefinitionDocumentReader 中已经完成，对 Bean 配置信息中使用最多的&lt;bean&gt;元素交由 BeanDefinitionParserDelegate 来解析，其解析实现的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//解析&lt;Bean&gt;元素的入口@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);} //解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name和别名属性@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { //获取&lt;Bean&gt;元素中的id属性值 String id = ele.getAttribute(ID_ATTRIBUTE); //获取&lt;Bean&gt;元素中的name属性值 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Bean&gt;元素中的alias属性值 List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); //将&lt;Bean&gt;元素中的所有name属性值存放到别名中 if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; //如果&lt;Bean&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); } } //检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt; //元素中是否包含子&lt;Bean&gt;元素 if (containingBean == null) { //检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复 checkNameUniqueness(beanName, aliases, ele); } //详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子元素 //&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子元素 //&lt;Bean&gt;元素，为解析的Bean使用别名向IOC容器注册 beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀 String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } //当解析出错时，返回null return null;}//详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析//由于上面的方法中已经对Bean的id、name和别名等属性进行了处理//该方法中主要处理除这三个以外的其他属性数据@Nullablepublic AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { //记录解析的&lt;Bean&gt; this.parseState.push(new BeanEntry(beanName)); //这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成 String className = null; //如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值 if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { //根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition //为载入Bean定义信息做准备 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //对&lt;Bean&gt;元素的meta(元信息)属性解析 parseMetaElements(ele, bd); //对&lt;Bean&gt;元素的lookup-method属性解析 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //对&lt;Bean&gt;元素的replaced-method属性解析 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析&lt;Bean&gt;元素的构造方法设置 parseConstructorArgElements(ele, bd); //解析&lt;Bean&gt;元素的&lt;property&gt;设置 parsePropertyElements(ele, bd); //解析&lt;Bean&gt;元素的qualifier属性 parseQualifierElements(ele, bd); //为当前解析的Bean设置所需的资源和依赖对象 bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } //解析&lt;Bean&gt;元素出错时，返回null return null;} 只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring配置文件中&lt;Bean&gt;元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。注意：在解析&lt;Bean&gt;元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类BeanDefinition，将&lt;Bean&gt;元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。上面方法中一些对一些配置如元信息(meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不多，我们在使用 Spring 的&lt;Bean&gt;元素时，配置最多的是&lt;property&gt;属性，因此我们下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。 载入&lt;property&gt;元素 BeanDefinitionParserDelegate 在解析&lt;Bean&gt;调用 parsePropertyElements()方法解析&lt;Bean&gt;元素中的&lt;property&gt;属性子元素，解析源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素 public void parsePropertyElements(Element beanEle, BeanDefinition bd) { //获取&lt;Bean&gt;元素中所有的子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析 if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { parsePropertyElement((Element) node, bd); } } }//解析&lt;property&gt;元素 public void parsePropertyElement(Element ele, BeanDefinition bd) { //获取&lt;property&gt;元素的名字 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(\"Tag 'property' must have a 'name' attribute\", ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。 //即如果在同一个Bean中配置同名的property，则只有第一个起作用 if (bd.getPropertyValues().contains(propertyName)) { error(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele); return; } //解析获取property的值 Object val = parsePropertyValue(ele, bd, propertyName); //根据property的名字和值创建property实例 PropertyValue pv = new PropertyValue(propertyName, val); //解析&lt;property&gt;元素中的属性 parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); } }//解析获取property值 @Nullable public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) { String elementName = (propertyName != null) ? \"&lt;property&gt; element for property '\" + propertyName + \"'\" : \"&lt;constructor-arg&gt; element\"; // Should only have one child element: ref, value, list, etc. //获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list,etc等 NodeList nl = ele.getChildNodes(); Element subElement = null; for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //子元素不是description和meta属性 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !nodeNameEquals(node, META_ELEMENT)) { // Child element is what we're looking for. if (subElement != null) { error(elementName + \" must not contain more than one sub-element\", ele); } else { //当前&lt;property&gt;元素包含有子元素 subElement = (Element) node; } } } //判断property的属性值是ref还是value，不允许既是ref又是value boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); if ((hasRefAttribute &amp;&amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) { error(elementName + \" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele); } //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference //这个对象封装了ref信息 if (hasRefAttribute) { String refName = ele.getAttribute(REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(elementName + \" contains empty 'ref' attribute\", ele); } //一个指向运行时所依赖对象的引用 RuntimeBeanReference ref = new RuntimeBeanReference(refName); //设置这个ref的数据对象是被当前的property对象所引用 ref.setSource(extractSource(ele)); return ref; } //如果属性是value，创建一个value的数据对象TypedStringValue //这个对象封装了value信息 else if (hasValueAttribute) { //一个持有String类型值的对象 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); //设置这个value数据对象是被当前的property对象所引用 valueHolder.setSource(extractSource(ele)); return valueHolder; } //如果当前&lt;property&gt;元素还有子元素 else if (subElement != null) { //解析&lt;property&gt;的子元素 return parsePropertySubElement(subElement, bd); } else { // Neither child element nor \"ref\" or \"value\" attribute found. //propery属性中既不是ref，也不是value属性，解析出错返回null error(elementName + \" must specify a ref or value\", ele); return null; } } @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) { return parsePropertySubElement(ele, bd, null); } 通过对上述源码的分析，我们可以了解在 Spring 配置文件中，&lt;Bean&gt;元素中&lt;property&gt;元素的相关配置是如何处理的： ref 被封装为指向依赖对象一个引用。 value 配置都会封装成一个字符串类型的对象。 ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来。在方法的最后对于&lt;property&gt;元素的子元素通过 parsePropertySubElement ()方法解析，我们继续分析该方法的源码，了解其解析过程。 载入&lt;property&gt;子元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//解析&lt;property&gt;元素中ref,value或者集合等子元素 @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) { //如果&lt;property&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析内嵌元素 if (!isDefaultNamespace(ele)) { return parseNestedCustomElement(ele, bd); } //如果子元素是bean，则使用解析&lt;Bean&gt;元素的方法解析 else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent else if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. //获取&lt;property&gt;元素中parent属性值，引用父级容器中的Bean refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; if (!StringUtils.hasLength(refName)) { error(\"'bean' or 'parent' is required for &lt;ref&gt; element\", ele); return null; } } if (!StringUtils.hasText(refName)) { error(\"&lt;ref&gt; element contains empty target attribute\", ele); return null; } //创建ref类型数据，指向被引用的对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); //设置引用类型值是被当前子元素所引用 ref.setSource(extractSource(ele)); return ref; } //如果子元素是&lt;idref&gt;，使用解析ref元素的方法解析 else if (nodeNameEquals(ele, IDREF_ELEMENT)) { return parseIdRefElement(ele); } //如果子元素是&lt;value&gt;，使用解析value元素的方法解析 else if (nodeNameEquals(ele, VALUE_ELEMENT)) { return parseValueElement(ele, defaultValueType); } //如果子元素是null，为&lt;property&gt;设置一个封装null值的字符串数据 else if (nodeNameEquals(ele, NULL_ELEMENT)) { // It's a distinguished null value. Let's wrap it in a TypedStringValue // object in order to preserve the source location. TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; } //如果子元素是&lt;array&gt;，使用解析array集合子元素的方法解析 else if (nodeNameEquals(ele, ARRAY_ELEMENT)) { return parseArrayElement(ele, bd); } //如果子元素是&lt;list&gt;，使用解析list集合子元素的方法解析 else if (nodeNameEquals(ele, LIST_ELEMENT)) { return parseListElement(ele, bd); } //如果子元素是&lt;set&gt;，使用解析set集合子元素的方法解析 else if (nodeNameEquals(ele, SET_ELEMENT)) { return parseSetElement(ele, bd); } //如果子元素是&lt;map&gt;，使用解析map集合子元素的方法解析 else if (nodeNameEquals(ele, MAP_ELEMENT)) { return parseMapElement(ele, bd); } //如果子元素是&lt;props&gt;，使用解析props集合子元素的方法解析 else if (nodeNameEquals(ele, PROPS_ELEMENT)) { return parsePropsElement(ele); } //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null else { error(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele); return null; } } 通过上述源码分析，我们明白了在 Spring 配置文件中，对&lt;property&gt;元素中配置的 array、list、set、map、prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对&lt;list&gt;集合元素的解析方法进行源码分析，了解其实现过程。 载入&lt;list&gt;子元素 在 BeanDefinitionParserDelegate 类中的 parseListElement()方法就是具体实现解析&lt;property&gt;元素中的&lt;list&gt;集合子元素，源码如下： 1234567891011121314151617181920212223242526272829 //解析&lt;list&gt;集合子元素 public List&lt;Object&gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) { //获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); //获取&lt;list&gt;集合元素中的所有子节点 NodeList nl = collectionEle.getChildNodes(); //Spring中将List封装为ManagedList ManagedList&lt;Object&gt; target = new ManagedList&lt;&gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); //设置集合目标数据类型 target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); //具体的&lt;list&gt;元素解析 parseCollectionElements(nl, target, bd, defaultElementType); return target; }//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析 protected void parseCollectionElements( NodeList elementNodes, Collection&lt;Object&gt; target, @Nullable BeanDefinition bd, String defaultElementType) { //遍历集合所有节点 for (int i = 0; i &lt; elementNodes.getLength(); i++) { Node node = elementNodes.item(i); //节点不是description节点 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) { //将解析的元素加入集合中，递归调用下一个子元素 target.add(parsePropertySubElement((Element) node, bd, defaultElementType)); } } } 经过对 Spring Bean 配置信息转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将 XML形式定义的 Bean 配置信息转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是 Bean 配置信息中配置的 POJO 对象在 Spring IOC 容器中的映射，我们可以通过 AbstractBeanDefinition 为入口，看到了 IOC 容器进行索引、查询和操作。通过 Spring IOC 容器对 Bean 配置资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中BeanDefinition 存储的只是一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IOC 容器的初始化过程 分配注册策略 让我们继续跟踪程序的执行顺序，接下来我们来分析efaultBeanDefinitionDocumentReader 对Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement()方法中完成对Document对象的解析后得到封装BeanDefinition的BeanDefinitionHold对象 ，然后调用BeanDefinitionReaderUtils 的 registerBeanDefinition() 方法向IOC容器注册解析的Bean ，BeanDefinitionReaderUtils 的注册的源码如下： 12345678910111213141516//将解析的 BeanDefinitionHold 注册到容器中public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)throws BeanDefinitionStoreException { //获取解析的 BeanDefinition 的名称 String beanName = definitionHolder.getBeanName(); //向 IOC 容器注册 BeanDefinition registry.registerBeanDefinition(beanName,definitionHolder.getBeanDefinition()); //如果解析的 BeanDefinition 有别名，向容器为其注册别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { registry.registerAlias(beanName, alias); } }} 当调用 BeanDefinitionReaderUtils 向 IOC 容器注册解析的 BeanDefinition 时，真正完成注册功能的是 DefaultListableBeanFactory。 向容器注册 DefaultListableBeanFactory 中使用一个 HashMap 的集合对象存放 IOC 容器中注册解析的BeanDefinition，向 IOC 容器注册的主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//存储注册信息的BeanDefinitionprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);//向IOC容器注册解析的BeanDefiniton@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); //校验解析的BeanDefiniton if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Validation of bean definition failed\", ex); } } BeanDefinition oldBeanDefinition; oldBeanDefinition = this.beanDefinitionMap.get(beanName); if (oldBeanDefinition != null) { if (!isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName + \"': There is already [\" + oldBeanDefinition + \"] bound.\"); } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (this.logger.isWarnEnabled()) { this.logger.warn(\"Overriding user-defined bean definition for bean '\" + beanName + \"' with a framework-generated bean definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } else if (!beanDefinition.equals(oldBeanDefinition)) { if (this.logger.isInfoEnabled()) { this.logger.info(\"Overriding bean definition for bean '\" + beanName + \"' with a different definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } else { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Overriding bean definition for bean '\" + beanName + \"' with an equivalent definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } this.beanDefinitionMap.put(beanName, beanDefinition); } else { if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) //注册的过程中需要线程同步，以保证数据的一致性 synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); } this.frozenBeanDefinitionNames = null; } //检查是否有同名的BeanDefinition已经在IOC容器中注册 if (oldBeanDefinition != null || containsSingleton(beanName)) { //重置所有已经注册过的BeanDefinition的缓存 resetBeanDefinition(beanName); }} 至此，Bean 配置信息中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正完成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护。这些的注册的 Bean 定义信息是 IOC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。 基于Annotation的IOC初始化原理 Spring IOC 容器对于类级别的注解和类内部的注解分以下两种处理策略：1)、类级别的注解：如@Component、@Repository、@Controller、@Service 以及 JavaEE6 的@ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规则扫描读取注解 Bean 定义类，并将其注册到 Spring IOC 容器中。2)、类内部的注解：如@Autowire、@Value、@Resource 以及 EJB 和 WebService 相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过 Bean 后置注解处理器解析Bean 内部的注解。下面将根据这两种处理策略，分别分析 Spring 处理注解相关的源码。 定位 Bean 扫描路径 在Spring中管理注解Bean定义的容器有两个：AnnotationConfigApplicationContext和AnnotationConfigWebApplicationContex。这两个类是专门处理 Spring 注解方式配置的容器，直接依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext是AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。现在我们以 AnnotationConfigApplicationContext 为例看看它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry { //保存一个读取注解的Bean定义读取器，并将其设置到容器中 private final AnnotatedBeanDefinitionReader reader; //保存一个扫描指定类路径中注解Bean定义的扫描器，并将其设置到容器中 private final ClassPathBeanDefinitionScanner scanner; //默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其register() //方法注册配置类，并调用refresh()方法刷新容器，触发容器对注解Bean的载入、解析和注册过程 public AnnotationConfigApplicationContext() { this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) { super(beanFactory); this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } //最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的Bean自动注册到容器中 public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) { this(); register(annotatedClasses); refresh(); } //该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的Spring Bean，将其注册到容器中 public AnnotationConfigApplicationContext(String... basePackages) { this(); scan(basePackages); refresh(); } @Override public void setEnvironment(ConfigurableEnvironment environment) { super.setEnvironment(environment); this.reader.setEnvironment(environment); this.scanner.setEnvironment(environment); } //为容器的注解Bean读取器和注解Bean扫描器设置Bean名称产生器 public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) { this.reader.setBeanNameGenerator(beanNameGenerator); this.scanner.setBeanNameGenerator(beanNameGenerator); getBeanFactory().registerSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator); } //为容器的注解Bean读取器和注解Bean扫描器设置作用范围元信息解析器 public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) { this.reader.setScopeMetadataResolver(scopeMetadataResolver); this.scanner.setScopeMetadataResolver(scopeMetadataResolver); } //为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的 //refresh()方法刷新容器，触发容器对新注册的Bean的处理 public void register(Class&lt;?&gt;... annotatedClasses) { Assert.notEmpty(annotatedClasses, \"At least one annotated class must be specified\"); this.reader.register(annotatedClasses); } //扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用 //refresh()方法刷新容器 public void scan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); this.scanner.scan(basePackages); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, Object... constructorArguments) { registerBean(null, annotatedClass, constructorArguments); } public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; annotatedClass, Object... constructorArguments) { this.reader.doRegisterBean(annotatedClass, null, beanName, null, bd -&gt; { for (Object arg : constructorArguments) { bd.getConstructorArgumentValues().addGenericArgumentValue(arg); } }); } @Override public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; beanClass, @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers) { this.reader.doRegisterBean(beanClass, supplier, beanName, null, customizers); }} 通过上面的源码分析，我们可以看啊到 Spring 对注解的处理分为两种方式： 直接将注解 Bean 注册到容器中: 可以在初始化容器时注册；也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容器，使得容器对注册的注解 Bean 进行处理。 通过扫描指定的包及其子包下的所有类: 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。接下来，将会对两种处理方式详细分析其实现过程。 读取Annotation元数据 当创建注解处理容器时，如果传入的初始参数是具体的注解 Bean 定义类时，注解容器读取并注册。 1) 、AnnotationConfigApplicationContext 通过调用注解 Bean 定义读取器 AnnotatedBeanDefinitionReader 的 register()方法向容器注册指定的注解 Bean，注解 Bean 定义读取器向容器注册注解 Bean 的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class AnnotatedBeanDefinitionReader { //注册多个注解Bean定义类 public void register(Class&lt;?&gt;... annotatedClasses) { for (Class&lt;?&gt; annotatedClass : annotatedClasses) { registerBean(annotatedClass); } } //注册一个注解Bean定义类 public void registerBean(Class&lt;?&gt; annotatedClass) { doRegisterBean(annotatedClass, null, null, null); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier) { doRegisterBean(annotatedClass, instanceSupplier, null, null); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, String name, @Nullable Supplier&lt;T&gt; instanceSupplier) { doRegisterBean(annotatedClass, instanceSupplier, name, null); } //Bean定义读取器注册注解Bean定义的入口方法 @SuppressWarnings(\"unchecked\") public void registerBean(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers) { doRegisterBean(annotatedClass, null, null, qualifiers); } //Bean定义读取器向容器注册注解Bean定义类 @SuppressWarnings(\"unchecked\") public void registerBean(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers) { doRegisterBean(annotatedClass, null, name, qualifiers); } //Bean定义读取器向容器注册注解Bean定义类 &lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name, @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) { //根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构 AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) { return; } abd.setInstanceSupplier(instanceSupplier); //解析注解Bean定义的作用域，若@Scope(\"prototype\")，则Bean为原型类型； //若@Scope(\"singleton\")，则Bean为单态类型 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); //为注解Bean定义设置作用域 abd.setScope(scopeMetadata.getScopeName()); //为注解Bean定义生成Bean名称 String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry)); //处理注解Bean定义中的通用注解 AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); //如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。 //主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解 //Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称 if (qualifiers != null) { for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) { //如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选 if (Primary.class == qualifier) { abd.setPrimary(true); } //如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置， //则该Bean为预实例化 else if (Lazy.class == qualifier) { abd.setLazyInit(true); } //如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一 //个autowiring自动依赖注入装配限定符，该Bean在进autowiring //自动依赖注入装配时，根据名称装配限定符指定的Bean else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } for (BeanDefinitionCustomizer customizer : definitionCustomizers) { customizer.customize(abd); } //创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); //根据注解Bean定义类中配置的作用域，创建相应的代理对象 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); //向IOC容器注册注解Bean类定义对象 BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } private static Environment getOrCreateEnvironment(BeanDefinitionRegistry registry) { Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); if (registry instanceof EnvironmentCapable) { return ((EnvironmentCapable) registry).getEnvironment(); } return new StandardEnvironment(); }} 从上面的源码我们可以看出，注册注解 Bean 定义类的基本步骤：a、需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。 b、使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定义类中通用的注解。c、使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。d、通过 BeanDefinitionReaderUtils 向容器注册 Bean。 2)、AnnotationScopeMetadataResolver 解析作用域元数据 AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型，其源码如下： 12345678910111213141516171819202122232425262728//解析注解Bean定义类中的作用域元信息@Overridepublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) { ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) { AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; //从注解Bean定义类的属性中查找属性为”Scope”的值，即@Scope注解的值 //annDef.getMetadata().getAnnotationAttributes()方法将Bean //中所有的注解和注解的值存放在一个map集合中 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); //将获取到的@Scope注解的值设置到要返回的对象中 if (attributes != null) { metadata.setScopeName(attributes.getString(\"value\")); //获取@Scope注解中的proxyMode属性值，在创建代理对象时会用到 ScopedProxyMode proxyMode = attributes.getEnum(\"proxyMode\"); //如果@Scope的proxyMode属性为DEFAULT或者NO if (proxyMode == ScopedProxyMode.DEFAULT) { //设置proxyMode为NO proxyMode = this.defaultProxyMode; } //为返回的元数据设置proxyMode metadata.setScopedProxyMode(proxyMode); } } //返回解析的作用域元信息对象 return metadata;} 上述代码中的 annDef.getMetadata().getAnnotationAttributes()方法就是获取对象中指定类型的注解的值。 3)、AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解 AnnotationConfigUtils 类的 processCommonDefinitionAnnotations()在向容器注册 Bean 之前，首先对注解 Bean 定义类中的通用 Spring 注解进行处理，源码如下： 12345678910111213141516171819202122232425262728293031323334353637//处理Bean定义中通用注解 static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) { AnnotationAttributes lazy = attributesFor(metadata, Lazy.class); //如果Bean定义中有@Lazy注解，则将该Bean预实例化属性设置为@lazy注解的值 if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\"value\")); } else if (abd.getMetadata() != metadata) { lazy = attributesFor(abd.getMetadata(), Lazy.class); if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\"value\")); } } //如果Bean定义中有@Primary注解，则为该Bean设置为autowiring自动依赖注入装配的首选对象 if (metadata.isAnnotated(Primary.class.getName())) { abd.setPrimary(true); } //如果Bean定义中有@ DependsOn注解，则为该Bean设置所依赖的Bean名称， //容器将确保在实例化该Bean之前首先实例化所依赖的Bean AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class); if (dependsOn != null) { abd.setDependsOn(dependsOn.getStringArray(\"value\")); } if (abd instanceof AbstractBeanDefinition) { AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd; AnnotationAttributes role = attributesFor(metadata, Role.class); if (role != null) { absBd.setRole(role.getNumber(\"value\").intValue()); } AnnotationAttributes description = attributesFor(metadata, Description.class); if (description != null) { absBd.setDescription(description.getString(\"value\")); } } } 4)、AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略 AnnotationConfigUtils 类的 applyScopedProxyMode()方法根据注解 Bean 定义类中配置的作用域@Scope 注解的值，为 Bean 定义应用相应的代理模式，主要是在 Spring 面向切面编程(AOP)中使用。源码如下： 123456789101112131415//根据作用域为Bean应用引用的代码模式 static BeanDefinitionHolder applyScopedProxyMode( ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) { //获取注解Bean定义类中@Scope注解的proxyMode属性值 ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode(); //如果配置的@Scope注解的proxyMode属性值为NO，则不应用代理模式 if (scopedProxyMode.equals(ScopedProxyMode.NO)) { return definition; } //获取配置的@Scope注解的proxyMode属性值，如果为TARGET_CLASS //则返回true，如果为INTERFACES，则返回false boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS); //为注册的Bean创建相应模式的代理对象 return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass); } 这段为 Bean 引用创建相应模式的代理，这里不做深入的分析。 5)、BeanDefinitionReaderUtils 向容器注册 Bean BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理BeanDefinition 的 HashMap 中。 扫描指定包并解析为 BeanDefinition 当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的包及其子包，将扫描到的注解 Bean 定义载入并注册。 1)、ClassPathBeanDefinitionScanner 扫描给定的包及其子包 AnnotationConfigApplicationContext 通过调用类路径Bean定义扫描器ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//创建一个类路径Bean定义扫描器public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { this(registry, true);}//为容器创建一个类路径Bean定义扫描器，并指定是否使用默认的扫描过滤规则。//即Spring默认扫描配置：@Component、@Repository、@Service、@Controller//注解的Bean，同时也支持JavaEE6的@ManagedBean和JSR-330的@Named注解public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) { this(registry, useDefaultFilters, getOrCreateEnvironment(registry));}public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment) { this(registry, useDefaultFilters, environment, (registry instanceof ResourceLoader ? (ResourceLoader) registry : null));}public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) { Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); //为容器设置加载Bean定义的注册器 this.registry = registry; if (useDefaultFilters) { registerDefaultFilters(); } setEnvironment(environment); //为容器设置资源加载器 setResourceLoader(resourceLoader);}//调用类路径Bean定义扫描器入口方法public int scan(String... basePackages) { //获取容器中已经注册的Bean个数 int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); //启动扫描器扫描给定包 doScan(basePackages); // Register annotation config processors, if necessary. //注册注解配置(Annotation config)处理器 if (this.includeAnnotationConfig) { AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } //返回注册的Bean个数 return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);}//类路径Bean定义扫描器扫描给定包及其子包protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); //创建一个集合，存放扫描到Bean定义的封装类 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;(); //遍历扫描所有给定的包 for (String basePackage : basePackages) { //调用父类ClassPathScanningCandidateComponentProvider的方法 //扫描给定类路径，获取符合条件的Bean定义 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); //遍历扫描到的Bean for (BeanDefinition candidate : candidates) { //获取Bean定义类中@Scope注解的值，即获取Bean的作用域 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); //为Bean设置注解配置的作用域 candidate.setScope(scopeMetadata.getScopeName()); //为Bean生成名称 String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); //如果扫描到的Bean不是Spring的注解Bean，则为Bean设置默认值， //设置Bean的自动依赖注入装配属性等 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } //如果扫描到的Bean是Spring的注解Bean，则处理其通用的Spring注解 if (candidate instanceof AnnotatedBeanDefinition) { //处理注解Bean中通用的注解，在分析注解Bean定义类读取器时已经分析过 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } //根据Bean名称检查指定的Bean是否需要在容器中注册，或者在容器中冲突 if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); //根据注解中配置的作用域，为Bean应用相应的代理模式 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //向容器注册扫描到的Bean registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions;} 类路径 Bean 定义扫描器 ClassPathBeanDefinitionScanner 主要通过findCandidateComponents()方法调用其父类 ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下的类。 2)、ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类 ClassPathScanningCandidateComponentProvider 类的 findCandidateComponents()方法具体实现扫描给定类路径包的功能，主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//扫描给定类路径的包public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) { return addCandidateComponentsFromIndex(this.componentsIndex, basePackage); } else { return scanCandidateComponents(basePackage); }}private Set&lt;BeanDefinition&gt; addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) { //创建存储扫描到的类的集合 Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); try { Set&lt;String&gt; types = new HashSet&lt;&gt;(); for (TypeFilter filter : this.includeFilters) { String stereotype = extractStereotype(filter); if (stereotype == null) { throw new IllegalArgumentException(\"Failed to extract stereotype from \"+ filter); } types.addAll(index.getCandidateTypes(basePackage, stereotype)); } boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (String type : types) { //为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type); //如果扫描到的类符合容器配置的过滤规则 if (isCandidateComponent(metadataReader)) { //通过汇编(ASM)读取资源字节码中的Bean定义元信息 AnnotatedGenericBeanDefinition sbd = new AnnotatedGenericBeanDefinition( metadataReader.getAnnotationMetadata()); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Using candidate component class from index: \" + type); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + type); } } } else { if (traceEnabled) { logger.trace(\"Ignored because matching an exclude filter: \" + type); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates;}private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\"Scanning \" + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Identified candidate component class: \" + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + resource); } } } else { if (traceEnabled) { logger.trace(\"Ignored because not matching any filter: \" + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); } } else { if (traceEnabled) { logger.trace(\"Ignored because not readable: \" + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates;} 注册注解 BeanDefinition AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版，它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean 定义源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//载入注解Bean定义资源@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) { //为容器设置注解Bean定义读取器 AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory); //为容器设置类路径Bean定义扫描器 ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory); //获取容器的Bean名称生成器 BeanNameGenerator beanNameGenerator = getBeanNameGenerator(); //为注解Bean定义读取器和类路径扫描器设置Bean名称生成器 if (beanNameGenerator != null) { reader.setBeanNameGenerator(beanNameGenerator); scanner.setBeanNameGenerator(beanNameGenerator); beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator); } //获取容器的作用域元信息解析器 ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver(); //为注解Bean定义读取器和类路径扫描器设置作用域元信息解析器 if (scopeMetadataResolver != null) { reader.setScopeMetadataResolver(scopeMetadataResolver); scanner.setScopeMetadataResolver(scopeMetadataResolver); } if (!this.annotatedClasses.isEmpty()) { if (logger.isInfoEnabled()) { logger.info(\"Registering annotated classes: [\" + StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + \"]\"); } reader.register(this.annotatedClasses.toArray(new Class&lt;?&gt;[this.annotatedClasses.size()])); } if (!this.basePackages.isEmpty()) { if (logger.isInfoEnabled()) { logger.info(\"Scanning base packages: [\" + StringUtils.collectionToCommaDelimitedString(this.basePackages) + \"]\"); } scanner.scan(this.basePackages.toArray(new String[this.basePackages.size()])); } //获取容器定义的Bean定义资源路径 String[] configLocations = getConfigLocations(); //如果定位的Bean定义资源路径不为空 if (configLocations != null) { for (String configLocation : configLocations) { try { //使用当前容器的类加载器加载定位路径的字节码类文件 Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader()); if (logger.isInfoEnabled()) { logger.info(\"Successfully resolved class for [\" + configLocation + \"]\"); } reader.register(clazz); } catch (ClassNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(\"Could not load class for config location [\" + configLocation + \"] - trying package scan. \" + ex); } //如果容器类加载器加载定义路径的Bean定义资源失败 //则启用容器类路径扫描器扫描给定路径包及其子包中的类 int count = scanner.scan(configLocation); if (logger.isInfoEnabled()) { if (count == 0) { logger.info(\"No annotated classes found for specified class/package [\" + configLocation + \"]\"); } else { logger.info(\"Found \" + count + \" annotated classes in package [\" + configLocation + \"]\"); } } } } }} 容器初始化小结 现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤：1、初始化的入口在容器实现中的 refresh()调用来完成。2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition(),其中的大致过程如下：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等方式来定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源，也就是说Bean定义文件时通过抽象成Resource来被IOC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册,往往使用的是XmlBeanDefinitionReader 来解析Bean的XML定义文件 - 实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用BeanDefinition对象来表示-这个名字可以让我们想到loadBeanDefinition(),registerBeanDefinition()这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有Bean 信息的场所，以后对 Bean 的操作都是围绕这个 HashMap 来实现的。然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring本身提供了对声明式载入web应用程序用法的应用程序上下文,并将其存储在ServletContext中的框架实现。以下是容器初始化全过程的时序图：","link":"/2019/08/21/Spring-2019-08-渐入Spring-IOC/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"委派","slug":"委派","link":"/tags/委派/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"单例","slug":"单例","link":"/tags/单例/"},{"name":"装饰者","slug":"装饰者","link":"/tags/装饰者/"},{"name":"观察者","slug":"观察者","link":"/tags/观察者/"},{"name":"策略","slug":"策略","link":"/tags/策略/"},{"name":"模板方法","slug":"模板方法","link":"/tags/模板方法/"},{"name":"代理","slug":"代理","link":"/tags/代理/"},{"name":"适配器","slug":"适配器","link":"/tags/适配器/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"原型模式","slug":"原型模式","link":"/tags/原型模式/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Spring IOC","slug":"Spring-IOC","link":"/tags/Spring-IOC/"},{"name":"Spring DI","slug":"Spring-DI","link":"/tags/Spring-DI/"}],"categories":[{"name":"建站笔记","slug":"建站笔记","link":"/categories/建站笔记/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}