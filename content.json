{"pages":[{"title":"Archives","text":"","link":"/archives/index.html"},{"title":"关于","text":"心怀恐惧，方能无畏。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"搭建hexo blog","text":"一、设置SSH1.多ssh配置执行 原因：由于本地已为gitee创建过默认公钥“id_rsa”，发布到github需单独配置公钥 使用git bash执行命令如下： 123456789101112$ cd ~$ md .ssh $ ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;Enter file in which to save the key (/c/Users/hp/.ssh/id_rsa):my_github$ ssh-agent bash$ ssh-add my_github$ ssh-add -l$ cat my_github.pub复制内容到github ssh keys$ ssh -T git@my_github.github.comHi UserName! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 二、hexo搭建1.hexo _config.yml配置 更改如下代码： 12345deploy:type: gitrepo: git@my_github.github.com:xxx/xxx.github.io.gitbranch: master my_github是上面配置的公钥名称 注意：每个参数后面“：”紧接着要写一个空格，不能直接跟value，否则构建失败2.hexo 常用基本语法 hexo clean 清空public文件夹 hexo g 构建 hexo s 启动server hexo d 推送到git hub hexo new xx创建名为“xx”的文章","link":"/2019/04/14/搭建hexo博客/"},{"title":"Linux学习（一）：命令基本使用","text":"常用Linux命令的基本使用1.cd 切换文件夹（change directory） cd /home绝对路径，以根目录开头 cd admin相对路径，不以根目录开头 cd .. 返回上一级目录 cd ~ 到自己家的目录（/home/admin） cd - 在当前目录和最近的一个历史操作目录切换 2.pwd 查看当前目录所在路径（print wrok directory）3.ls 查看当前目录内容（list） ls -l 显示详细列表 ls -lh 把文件大小以人性化的方式显示 ls -a 显示所有文件，包含隐藏文件，隐藏文件是.开头的文件 ll 等于ls -l 命令可组合使用，比如ll -a 、ls -hla。 -后面的关键词顺序不固定 4.mkdir 创建目录（make directory） mkdir test 在当前目录创建文件夹取名“test” mkdir /home/admin/test 在绝对路径创建文件夹 mkdir /home/admin/a/test -p 如果上级目录不存在，加上-p自动创建目录 mkdir test1 test2 在当前目录创建多个文件夹 mkdir a/{b,c} 在指定目录下创建多个文件夹 mkdir .test 以.开头创建隐藏文件夹 每个目录下都有.、.. 两个隐藏目录 5.touch 如果文件不存在，新建文件（touch） touch abc.txt 在当前目录下创建，如果指定了目录，必须保证上级目录存在 touch .abc 创建隐藏文件 gedit abc.txt 打开文件进行编辑，如果文件不存在则创建文件 6.rm 删除指定文件名（remove） rm a.txt 删除文件 rm abc -r 删除文件夹 rm * -r 删除所有文件和文件夹（不能删除隐藏文件） 7.clear 清屏（clear）8.cp 拷贝文件（copy） cp a.txt b.txt 拷贝源文件a.txt到目标文件b.txt cp abc abc_bak -r 拷贝文件夹 cp选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 不常用，默认会加上。覆盖已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 9.mv 移动/剪切、重命名（move） mv a.txt a 剪切a.txt到a文件夹下，如果要改名字修改后者路径即可 mv选项 含义 -f 禁止交互式操作，如果覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问用户回答以避免误覆盖文件 -v 显示移动进度 注意：mv对文件夹可以直接移动，不需要-r 10.&gt; 重定向 ls &gt; 1.txt 把ls命令返回的结果输出到文件中，会覆盖之前的数据，默认情况ls的返回结果是显示在屏幕中 ls&gt;&gt;1.txt把ls命令返回的结果输出到1.txt中，以追加的方式。 11.cat查看文件内容 cat 1.txt 把文件的内容全部显示到屏幕中 cat 1.txt 2.txt 把两个文件内容全部显示到屏幕中 cat 1.txt 2.txt &gt;3.txt把多个文件的内容合并到新的文件中 12.more查看文件内容，可以分页显示 more 1.txt 查看内容多的文件，按空格键往下翻页，按b键往回翻页，按enter下一行，按q键退出","link":"/2019/05/06/Linux学习（一）：命令基本使用/"},{"title":"Linux学习（五）：文件解压缩","text":"文件解压缩tar 归档 打包 打包 tar cvf a.tar 1.txt 2.txt ：f必须放到最后，f后面的第一个参数代表要生成的文件名，后面所有的参数是要打包的文件 tar tf a.tar ： 列出包里面的文件 解包 tar xvf a.tar 如果没有写目录，把包里面的文件解开放到当前目录 tar xvf a.tar -C tar 解压到指定文件夹，文件夹需要提前创建好 gzip 压缩文件 生成压缩文件 ① 打包tar cf a.tar * 生成a.tar② 压缩gzip -r a.tar 生成a.tar.gz文件 解压压缩文件 ① 解压gzip -d a.tar.gz 生成a.tar② 解包tar xf a.tar -C ~/atar 解包到指定文件夹中 一步到位打包并且压缩tar czf b.tar.gz *.txt 以gzip的方式打包并且压缩 一步到位解压并且解包tar zxf b.tar.gz -C btar 以gzip的方式解压缩并且解包 bzip2 压缩文件（用法同gzip） 压缩 tar jcf j.tar.bz2 *.txt 压缩文件 解压 tar xjf j.tar.bz2 -C jtar 解压文件 zip 压缩文件 压缩 zip -r zz *.txt zz 代表要生成的压缩文件，不需要写扩展名，会自动生成zip扩展名 解压 uzip -d zz zz.zip 解压时会自动创建目录 压缩率 zip&lt;gzip&lt;bzip2 通用性 zip&gt;gzip&gt;bzip2综合考虑：linux系统中一般使用gzip","link":"/2019/05/06/Linux学习（五）：文件解压缩/"},{"title":"Linux学习（三）：管道和链接","text":"管道和链接1.|管道 ls -l / | more 一个命令的输出可以通过管道交给另一个命令的输出 2.ln链接 软链接：软链接不占用磁盘空间，源文件删除则软链接失效。 ln -s 源文件 链接文件 注意：如果软链接文件和源文件不在统一目录，源文件要使用绝对路径，不能使用相对路径，因为软链接只会记录路径名称。 硬链接：硬链接只能链接普通文件，不能链接目录。本身占用空间，与源文件同步发生变化，使用ll查看文件时，有一个数字，代表有几个文件能同步发生变化。 ln 源文件 链接文件","link":"/2019/05/06/Linux学习（三）：管道和链接/"},{"title":"Linux学习（二）：权限及通配符","text":"ls 查看权限执行touch a 新建文件a,执行命令 ll -h查看列表文件a的详细信息（下面用作例子详细介绍） -rw-rw-r–. 1 test test 0 1月 4 11:11 a 解读\\列名 权限 硬件链接数 文件属主 文件所属的组 文件大小 文件修改时间 文件名 信息 -rw-rw-r–. 1 test test 0 1月 4 11:11 a 详解1 第一个字符[-d]，d代表文件夹，-代表文件 - - - - - - 详解2 第一个字符后9个字符分为三组[-rwx][-rwx][-rwx]。r代表可读，w代表可写，x代表可执行-代表非。 - - - - - - 详解3 三组[-rwx][-rwx][-rwx]中。第一组：当前用户的权限，第二组：当前用户组对文件的权限，第三组：其他用户组的权限 - - - - - - 文件夹ceshi的详细信息 drwxrwxr-x. 2 test test 6 1月 4 11:10 ceshi chmod设置权限1.chmod字母法 语 法： chmod [ugoa] [+-=] [rwx] 文件demo：chmod u+x test.txt 给文件拥有者添加可执行权限 u:user表示文件所有者 g：group 表示文件所有者属于同一组（group）者，即用户组 o：other表示其他人 a：All 表示所有人 +：增加权限 -：撤销权限 =：设定权限 r：red 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容 w：write表示可写入，对于一个目录，如果没有w权限，那么就意味着不能再目录下创建文件 x：excute 表示可执行，对于一个目录，如果没有x权限，就意味着不能通过cd进入这个目录。 2.chmod数字法 语 法：chmod [124][124][124] 文件 数字 说明 4 r 读取权限 2 w 写入权限 1 x 执行权限 0 - 不具任何权限 demo：chmod 123 a.txt 第一位数字代表自己的权限 第二位数字代表自己组的权限 第三位数字代表其他人的权限 3 =1+2 代表w+x 通配符 通配符 含义 * 代表文件名中所有字符 ls te* 查找以te开头的文件 ls *html 查找html结尾的文件 ？ 代表文件名任意一个字符 ls ?.c 只找第一个字符任意，后缀为.c的文件 [abc] 匹配abc中任意一个 [a-f] 匹配从a到f 范围内的任意一个字符 ls [a-f]* 找到从a到f范围内的任意一个字符开头的文件 ls a-f 找到名字为a-f的文件，当-处于[]之外失去通配符的作用 \\ 转义字符","link":"/2019/05/06/Linux学习（二）：权限及通配符/"},{"title":"Linux学习（四）：四剑客之二（grep、find）","text":"linux四剑客grep 查找文件内容 grep hello test.txt 在某个文件中查找包含hello的内容，只要一行中有hello会把整行显示 grep -niv helle test.txt n显示查找到的内容行号，i查找时不区分大小写，v反向查找（查找不包含hello的行） grep -n hello home/admin -r 查找整个目录中的所有文件，包含hello的内容 find 查找文件 find /home -name 1.txt 在/home目录下查找文件名为1.txt的文件，输出文件路径 find /home -name '*.txt'在/home目录下查找所有后缀为.txt的文件。注意：如果查找模糊文件名，需对文件名参数加上引号。","link":"/2019/05/06/Linux学习（四）：四剑客之二（grep、find）/"},{"title":"Linux学习（六）：其他命令","text":"which 查看命令位置 which zip 查看zip命令的可执行文件所在位置，但无法查找cd这样的shell类型命令。 su 切换账号 su Centos下切换到root用户命令su test 切换到test用户 root切换其他用户不用输入密码，反之要输入密码。 passwd 重置密码 passwd 修改当前用户密码，密码有复杂度要求passwd test 切换到root后执行该命令，修改test用户密码，无强制要求密码复杂度 exit 退出当前用户 注意：如果使用su 登录root后再使用exit 只是退出root，当前窗口不会关闭。 who 查看当前登录的客户端，或者当前登录的命令终端 “pts”代表终端“tty”代表用户登录了操作系统pkill -kill -t tty1 杀死一个客户端连接 reboot、shutdown 重启、关机 命令 含义 reboot 重新启动操作系统 shutdown -r now 重启操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now代表时间为0的状态 shutdown -h 20:35 系统在今天的20:35会关机 shutdown -h +10 系统在十分钟之后自动关机 ，要取消则按ctrl+c","link":"/2019/05/06/Linux学习（六）：其他命令/"},{"title":"设计模式（一）：单例模式","text":"单例模式的应用场景单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。 例如，国家主席、公司 CEO、部门经理等。在 J2EE标准中，ServletContext、 ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext；数据库的连接池也都是单例形式。 常见实现饿汉式单例：Spring中IOC容器ApplicationContext。 饿汉式单例饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题。 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。 12345678910111213public class HungrySingleton { //法1 private static final HungrySingleton instance = new HungrySingleton(); //法2 // static { // instance = new HungrySingleton(); // } private HungrySingleton() { } public static HungrySingleton getInstance(){ return instance; }} 懒汉式单例懒汉式单例的特点是：被外部类调用的时候内部类才会加载. 1.同步锁懒汉式单例1234567891011private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; public static LazyDoubleCheckSingleton getInstance(){ if(lazyDoubleCheckSingleton ==null){ synchronized(LazyDoubleCheckSingleton.class){ if(lazyDoubleCheckSingleton ==null){ lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); } } } return lazyDoubleCheckSingleton; } 2.内部类懒汉式单例123456789101112131415161718192021public class LazyInnerClassSingleton { private LazyInnerClassSingleton() { System.out.println(\"构造方法\"); if (LazyHolder.LAZY!=null){ throw new RuntimeException(\"禁止通过反射创建此单例对象\"); } } public static final LazyInnerClassSingleton getInstance(){ System.out.println(\"getInstance\"); return LazyHolder.LAZY; } /** * 内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。 */ private static class LazyHolder{ private static final LazyInnerClassSingleton LAZY= new LazyInnerClassSingleton(); } public static void main(String []s ){ LazyInnerClassSingleton.getInstance(); }} 注册式单例1.容器缓存注册式单例123456789101112131415161718192021222324252627282930public class ContainerSingleton { private ContainerSingleton() { } private static final Map&lt;String,Object&gt; instanceMap = new HashMap&lt;&gt;(); public static final Object getBean(String className){ if(className==null||\"\".equals(className.trim())) return null; synchronized(instanceMap){ if (instanceMap.containsKey(className)){ return instanceMap.get(className); }else{ Object obj = null; try { Class clazz = Class.forName(className); obj = clazz.newInstance(); instanceMap.put(className,obj); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } return obj; } } }} 2.枚举注册式单例此方法即使通过反序列化也能获得单例 123456789101112131415public enum EnumSingleton { INSTANCE; private Object data; public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static EnumSingleton getInstance(){ return INSTANCE; }}","link":"/2019/08/04/设计模式（一）：单例模式/"},{"title":"设计模式（七）：委派模式","text":"委派模式委派模式（Delegate Pattern）的基本作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。委派模式在 Spring 中应用非常多，大家常用的 DispatcherServlet 其实就是用到了委派模式。现实生活中也常有委 派的场景发生，例如：老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板。","link":"/2019/08/08/设计模式（七）：委派模式/"},{"title":"设计模式（五）：模板方法模式","text":"模板方法模式定义模板模式通常又叫模板方法模式（Template Method Pattern）是指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤，属于行为性设计模式。模板方法适用于以下应用场景： 1、一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 2、各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。 示例 定义模板 12345678910111213public abstract class AbstTemplateMethod { public void templateMethod1(int p){ //抽象业务逻辑与模板逻辑灵活应用 p = p+10; p = method1(p); print(p); } abstract int method1(int p); private void print(int p){ System.out.println(p); }} 定义模板第一个业务类 1234567public class TemplateMethod1 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod1 p=\"); return p+1; }} 定义模板第二个业务类 1234567public class TemplateMethod2 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod2 p=\"); return p+2; }} 定义模板第n个业务类…. 测试 12345678public class TestTemplateMethod { public static void main(String[] args) { AbstTemplateMethod test = new TemplateMethod1(); test.templateMethod1(10); test = new TemplateMethod2(); test.templateMethod1(10); }}","link":"/2019/08/08/设计模式（五）：模板方法模式/"},{"title":"设计模式（三）：装饰者模式","text":"装饰者模式定义装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对 象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。 装饰模式主要包含以下角色。 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 样例定义抽象构件 123public interface IComponent { void operation();} 实现具体构件 123456public class ConcreteComponent implements IComponent{ @Override public void operation() { System.out.println(\"执行基本操作~\"); }} 定义抽象装饰（抽象可选） 123456789101112public abstract class AbstDecorator implements IComponent{ private IComponent component; public AbstDecorator(IComponent component) { this.component = component; } @Override public void operation() { System.out.println(\"执行抽象装饰\"); component.operation(); }} 实现具体装饰 123456789101112131415public class ConcreteDecorator extends AbstDecorator { public ConcreteDecorator(IComponent component) { super(component); } @Override public void operation() { method1(); super.operation(); } public void method1(){ System.out.println(\"执行附加的装饰方法\"); }} 测试 1234567public class DecoratorTest { public static void main(String[] args) { IComponent component = new ConcreteComponent(); IComponent d1 = new ConcreteDecorator(component); d1.operation(); }} console打印如下： 执行附加的装饰方法执行抽象装饰执行基本操作~ jdk典型装饰者场景：InputStream 与适配器模式的区别 装饰者模式 适配器模式 形式 是一种特殊的适配器模式 没有层级关系，装饰者有层级关系 定义 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留OOP关系 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 关系 满足is-a的关系 满足has-a的关系 功能 注重覆盖、扩展 注重兼容、转换 设计 前置考虑 后置考虑（重构） 优缺点优点 装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。 装饰者完全遵守开闭原则。 缺点 会出现更多的代码，更多的类，增加程序复杂性。 动态装饰时，多层装饰时会更复杂。","link":"/2019/08/08/设计模式（三）：装饰者模式/"},{"title":"设计模式（二）：代理模式","text":"代理模式（Proxy Pattern）定义是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用代理模式主要有两个目的：一、保护目标对象，二、增强目标对象。 常见实现SpringAop 静态代理（static proxy）抽象的说，就是代理对象持有被代理对象的引用进行方法增强。举个例子：在深圳租房子，我们自己去找房很难直接联系上房东。一般会联系中介或者管理处（proxy），间接的租房。有的全权代理的房东坐等收钱，而中介可以在收租前后做各种不需要告诉老板的事，比如装修一番再涨个价赚取中间商差价。 动态代理（dynamic proxy）动态，指的是不直接引用被代理对象，并且可以代理不同的对象。Spring AOP面向切面编程的原理正是如此。举个例子，快递公司要帮人寄送快递，但他不需要知道那个人是谁。只要按流程填写快递单就行了。“快递单”在这里就是被代理对象。沿用这个例子展开分析。 1.JDK Proxy12345678910111213141516171819202122232425/** * Created by miaozc on 2019-8-2. * 快递公司-动态代理发送快递 */public class ExpressCompanyJDKProxy implements InvocationHandler { private Object target; public Object getInstance(Object object)throws Exception{ this.target = object; Class&lt;?&gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object object = method.invoke(this.target,args); send(); return object; } public void send(){ System.out.println(\"jdk动态代理-快递公司发出快递！\"); }} 测试代码：12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));jdkCustomer.send(); JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。JDK Proxy 生成对象的步骤如下： 拿到被代理对象的引用，反射获取它所有的接口。 JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。 动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。 编译新生成的 Java 代码: $Proxy***.class。 再重新加载到 JVM 中运行。 以上这个过程就叫字节码重组。JDK 中有一个规范，在 ClassPath 下只要是$开头的 class文件一般都是自动生成的。查看代替后对象方式如下： 12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));byte [] bytes = ProxyGenerator.generateProxyClass(\"$Proxy0\",new Class[]{Person.class}); FileOutputStream os = new FileOutputStream(\"E://$Proxy0.class\"); 2. CGLib Proxy与JDK代理不同，CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现的动态代理。这样的做法弊端就是无法代理final关键字修饰的方法。.好处则更加明显，在频繁调用代理的情况下，省去了反射带来的开销。 代理实现： 12345678910111213141516171819202122232425public class ExpressCompanyCGLibProxy implements MethodInterceptor { public Object getInstance(Class&lt;?&gt; clazz,Class[] argumentTypes, Object[] arguments) throws Exception{ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); if(argumentTypes==null){ return enhancer.create(); }else{ return enhancer.create(argumentTypes, arguments); } } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { Object object = methodProxy.invokeSuper(o,objects); send(); return object; } public void send(){ System.out.println(\"cglib动态代理-快递公司发出快递！\"); }} 测试代码： 12345678910111213//构造方法所需参数Class[] argumentTypes = new Class[]{String.class};Object[] personArguments = new Object[]{\"王五\"};Object[] robotArguments = new Object[]{\"二哈\"};Customer cglibCustomer = (Customer) new ExpressCompanyCGLibProxy(). getInstance(Customer.class,argumentTypes,personArguments);Robot cglibRobot = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,argumentTypes,robotArguments);Robot cglibRobotCreate = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,null,null);cglibCustomer.send();cglibRobot.send();cglibRobotCreate.send(); 将 CGLib 代理后的 class 写入到磁盘： 1234//利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,\"E://cglib_proxy_class/\");ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\")); 我们会发现在 E://cglib_proxy_class 目录下多了三个 class 文件 ObjectName$$EnhancerByCGLIB$$3feeb52a.class CGLib生成的代理类，继承了被代理对象。重写了 被代理对象类的所有方法，并且生成代理的方法的增强逻辑以及增强逻辑所需要的方法。这直接导致了我们如果在拦截器里直接调用method.invoke()会死循环。所以我们切记在代理拦截器中应该使用methodProxy.invokeSuper(o,objects)。 ObjectName$$EnhancerByCGLIB$$3feeb52a$$FastClassByCGLIB$$6aad62f1.class 代理类的 FastClass。 Customer$$FastClassByCGLIB$$2669574a.class 被代理类的FastClass。 CGLib 动态代理执行代理方法效率之所以比 JDK的高是因为 Cglib 采用了 FastClass 机制，它的原理简单来说就是：为代理类和被代理类各生成一个 Class，这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高。FastClass 并不是跟代理类一块生成的，而是在第一次执行 MethodProxy.invoke()/invokeSuper() 时生成的并放在了缓存中。 CGLib 和 JDK 动态代理对比 JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。 JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。 Spring中的代理模式代理模式选择 当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理 当 Bean 没有实现接口时，Spring 选择 CGLib。 Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码： 1&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 静态代理和动态的本质区别 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。 代理模式的优缺点使用代理模式具有以下几个优点： 代理模式能将代理对象与真实被调用的目标对象分离。 一定程度上降低了系统的耦合度，扩展性好。 可以起到保护目标对象的作用。 可以对目标对象的功能增强。 当然，代理模式也是有缺点的： 代理模式会造成系统设计中类的数量增加。 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。 增加了系统的复杂度。","link":"/2019/08/04/设计模式（二）：代理模式/"},{"title":"设计模式（八）：策略模式","text":"策略模式策略模式（Strategy Pattern）是指定义了算法家族、分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。 策略模式的应用场景1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。 2、一个系统需要动态地在几种算法中选择一种。 策略模式在 JDK 源码中的体现首先来看一个比较常用的比较器 Comparator 接口，我们看到的一个大家常用的compare()方法，就是一个策略抽象实现： 1234public interface Comparator&lt;T&gt; { int compare(T o1, T o2); ... } Comparator 抽象下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作为排序策略，例如 Arrays 类的 parallelSort 方法等： 1234567public class Arrays { ... public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; cmp) { ... } ... } 策略模式在 Spring 源码中的应用Spring 的初始化也采用了策略模式，不同的类型的类采用不同的初始化策略。 12345public interface InstantiationStrategy { Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, Constructor&lt;?&gt; var4, @Nullable Object... var5) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, @Nullable Object var4, Method var5, @Nullable Object... var6) throws BeansException; } 顶层的策略抽象非常简单，但是它下面有两种策略 SimpleInstantiationStrategy 和CglibSubclassingInstantiationStrategy 123public class SimpleInstantiationStrategy implements InstantiationStrategy { ...} 123public class CglibSubclassingInstantiationStrategy extends SimpleInstantiationStrategy { ...} 说明在实际应用中多种策略之间还可以继承使用 策略模式的优缺点优点： 1、策略模式符合开闭原则。 2、避免使用多重条件转移语句，如 if…else…语句、switch 语句 3、使用策略模式可以提高算法的保密性和安全性。 缺点： 1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。 2、代码中会产生非常多策略类，增加维护难度。","link":"/2019/08/08/设计模式（八）：策略模式/"},{"title":"设计模式（六）：原型模式","text":"原型模式简介 原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 调用者不需要知道任何创建细节 属于创建型模式 使用场景 类初始化小号资源较多 new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等） 构造函数比较复杂 循环体中产生大量对象时 常见原型模式工具类1BeanUtil.copy(); 1JSON.paseObject(); 1Guava 利用Java提供的Cloneable接口实现浅克隆123456public Object shallowClone(Test target){ Test test = new Test(); test.a = target.a;//普通字段 test.object = target.object;//对象字段，拷贝的是引用地址 return test;} 深克隆1234567891011121314151617181920public Object deepClone(){ try{ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); QiTianDaSheng copy = (QiTianDaSheng)ois.readObject(); copy.birthday = new Date(); return copy; }catch (Exception e){ e.printStackTrace(); return null; }finally{ ...close; }} 深克隆例子1ArrayList.clone();//ArrayList重写了clone方法","link":"/2019/08/08/设计模式（六）：原型模式/"},{"title":"设计模式（四）：适配器模式","text":"适配器模式适配器模式（Adapter Pattern）是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作，属于结构型设计模式。 适配器适用于以下几种业务场景： 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。 生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。在中国民用电都是220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我们给手机充电时就需要使用电源适配器来进行转换。下面我们有代码来还原这个生活场 景，创建 AC220 类，表示 220V 交流电： 老版本逻辑 1234567public class AC220 { public int outputAC220V() { int output = 220; System.out.println(\"输出交流电\" + output + \"V\"); return output; }} 创建适配器接口 123public interface DC5 { int outputDC5V();} 创建适配器 123456789101112131415public class PowerAdapter implements DC5 { private AC220 ac220; public PowerAdapter(AC220 ac220) { this.ac220 = ac220; } @Override public int outputDC5V() { int adapterInput = ac220.outputAC220V(); //变压器 int adapterOutput = adapterInput / 44; System.out.println(\"使用 PowerAdapter 输入 AC:\" + adapterInput + \"V\" + \"输出 DC:\" + adapterOutput + \"V\"); return adapterOutput; }} 测试适配器 123456public class TestAdapter { public static void main(String[] args) { DC5 dc5 = new PowerAdapter(new AC220()); dc5.outputDC5V(); }} 适配器模式的优缺点优点 能提高类的透明性和复用，现有的类复用但不需要改变。 目标类和适配器类解耦，提高程序的扩展性。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。","link":"/2019/08/08/设计模式（四）：适配器模式/"},{"title":"设计模式：七大原则","text":"软件架构设计的七大原则一、开闭原则开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调 的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开 闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统， 例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间， 规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。 二、依赖倒置原则依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模 块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖 抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的 可读性和可维护性，并能够降低修改程序所造成的风险。 三、单一职责原则单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更 的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的 逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现， 进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的 可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个 Class/Interface/Method 只负责一项职责。 四、接口隔离原则接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点： 1、一个类对一类的依赖应该建立在最小的接口之上。 2、建立单一接口，不要建立庞大臃肿的接口。 3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。 接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解 是非常重要的。 五、迪米特法则迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又 叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪 米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 六、里氏替换原则里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对 象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对 象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下： 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类 方法的输入参数更宽松。 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即 方法的输出/返回值）要比父类更严格或相等。 使用里氏替换原则有以下优点： 约束继承泛滥，开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩 展性。降低需求变更时引入的风险。 里氏替换原则只存在父类与子类之间，约束继承泛滥。 七、合成复用原则合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组 合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。 设计原则总结学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都 遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的 场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。","link":"/2019/08/04/设计模式：七大原则/"},{"title":"设计模式：分类","text":"设计模式的分类跟据其目的（模式是用来做什么的）一、创建型(Creational)创建型模式主要用于创建对象。 抽象工厂模式(Abstract Factory) 建造者模式(Builder) 工厂方法模式(Factory Method) 原型模式(Prototype) 单例模式(Singleton) 二、结构型(Structural)结构型模式主要用于处理类或对象的组合。 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 三、行为型模式行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。 职责链模式(Chain of Responsibility) 命令模式(Command) 解释器模式(Interpreter) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Visitor) 根据范围（模式主要是用于处理类之间关系还是处理对象之间的关系）可分为类模式和对象模式两种 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是属于静态的。 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。","link":"/2019/08/04/设计模式：分类/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"单例","slug":"单例","link":"/tags/单例/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"委派","slug":"委派","link":"/tags/委派/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"模板方法","slug":"模板方法","link":"/tags/模板方法/"},{"name":"装饰者","slug":"装饰者","link":"/tags/装饰者/"},{"name":"代理","slug":"代理","link":"/tags/代理/"},{"name":"策略","slug":"策略","link":"/tags/策略/"},{"name":"原型模式","slug":"原型模式","link":"/tags/原型模式/"},{"name":"适配器","slug":"适配器","link":"/tags/适配器/"}],"categories":[{"name":"建站笔记","slug":"建站笔记","link":"/categories/建站笔记/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}