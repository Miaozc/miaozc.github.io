{"pages":[{"title":"关于","text":"心怀恐惧，方能无畏。","link":"/about/index.html"},{"title":"Archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"搭建hexo blog","text":"一、设置SSH1.多ssh配置执行 原因：由于本地已为gitee创建过默认公钥“id_rsa”，发布到github需单独配置公钥 使用git bash执行命令如下： 123456789101112$ cd ~$ md .ssh $ ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;Enter file in which to save the key (/c/Users/hp/.ssh/id_rsa):my_github$ ssh-agent bash$ ssh-add my_github$ ssh-add -l$ cat my_github.pub复制内容到github ssh keys$ ssh -T git@my_github.github.comHi UserName! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 二、hexo搭建1.hexo _config.yml配置 更改如下代码： 12345deploy:type: gitrepo: git@my_github.github.com:xxx/xxx.github.io.gitbranch: master my_github是上面配置的公钥名称 注意：每个参数后面“：”紧接着要写一个空格，不能直接跟value，否则构建失败2.hexo 常用基本语法 hexo clean 清空public文件夹 hexo g 构建 hexo s 启动server hexo d 推送到git hub hexo new xx创建名为“xx”的文章","link":"/2019/04/14/搭建hexo博客/"},{"title":"Spring、IOC、DI、AOP时序图","text":"Spring IOC时序图 Spring DI时序图 Spring AOP时序图 Spring MVC时序图","link":"/2019/08/23/Spring-2019-08-Spring、IOC、DI、AOP时序图/"},{"title":"Spring事务","text":"事务配置1234567891011121314151617181920212223242526272829303132333435&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\" rollback-for=\"Exception,RuntimeException,SQLException\"/&gt; &lt;tx:method name=\"remove*\" propagation=\"REQUIRED\" rollback-for=\"Exception,RuntimeException,SQLException\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"REQUIRED\" rollback-for=\"Exception,RuntimeException,SQLException\"/&gt; &lt;tx:method name=\"login\" propagation=\"NOT_SUPPORTED\"/&gt; &lt;tx:method name=\"query*\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"transactionAdvice\" pointcut-ref=\"transactionPointcut\"/&gt; &lt;aop:aspect ref=\"dataSource\"&gt; &lt;aop:pointcut id=\"transactionPointcut\" expression=\"execution(public * com.xxx..*.service..*Service.*(..))\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 事务原理事务基本概念事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。 特点：事务是恢复和并发控制的基本单位。事务应该具有 4 个属性：原子性、一致性、 隔离性、持久性。这四个属性通常称为 ACID 特性。 原子性（Automicity）: 一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（Consistency）: 事务必须是使数据库从一个一致性状态变到另一个一致性状态。 一致性与原子性是密切相关的。 隔离性（Isolation）: 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）: 持久性也称永久性（Permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何 影响。 事务基本原理Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。对于纯 JDBC 操作数据库，想要用到事务，可以按照以下步骤进行： 1、获取连接 Connection con = DriverManager.getConnection() 2、开启事务 con.setAutoCommit(true/false); 3、执行 CRUD 4、提交事务/回滚事务 con.commit() / con.rollback(); 5、关闭连接 conn.close(); 使用 Spring 的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由 Spirng 自动完成。 那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的 呢？解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。下面简单地介绍下，注解方式为例子 配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。 Spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入， 这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。 Spring事务的传播属性所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如何处理这些事务的行为。这些属性在 TransactionDefinition 中定义，具体常量的解释见下表： 常量名称 常量解释 PROPAGATION_REQUIRED 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring默认的事务的传播。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果， 内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 数据库隔离级别 隔离级别 导致的问题 Read-Uncommitted 导致脏读 Read-Committed 避免脏读，允许不可重复读和幻读 Repeatable-Read 避免脏读，不可重复读，允许幻读 Serializable 串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重 脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。 不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。 幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle 少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB Spring 中的隔离级别 常量 解释 ISOLATION_DEFAULT 这是个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。 ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 事务的嵌套我们通过分析一些嵌套事务的场景，来深入理解 Spring 事务传播的机制。假设外层事务 Service A 的 Method A() 调用内层 Service B 的 Method B() PROPAGATION_REQUIRED(Spring 默认)如果 ServiceB.MethodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行ServiceA.MethodA() 的时候 Spring 已经起了事务，这时调用 ServiceB.MethodB()， ServiceB.MethodB() 看到自己已经运行在 ServiceA.MethodA() 的事务内部，就不再起新的事务。 假如 ServiceB.MethodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在 ServiceA.MethodA() 或者在 ServiceB.MethodB() 内的任何地方出现异常， 事务都会被回滚。 PROPAGATION_REQUIRES_NEW比如我们设计 ServiceA.MethodA() 的事务级别为 PROPAGATION_REQUIRED， ServiceB.MethodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。 那么当执行到 ServiceB.MethodB() 的时候，ServiceA.MethodA() 所在的事务就会挂起，ServiceB.MethodB() 会起一个新的事务，等待 ServiceB.MethodB() 的事务完成以后，它才继续执行。他与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度, 因为ServiceB.MethodB()是一个新起的事务,那么就是存在两个不同的事务, 如果ServiceB.MethodB()已经提交, 那么ServiceA.MethodA()失败回滚ServiceB.MethodB()是不会回滚的. 如果ServiceB.MethodB()失败回滚, 如果他抛出异常被ServiceA.MethodA()捕获, ServiceA.MethodA()事务仍然可能提交(主要看 B 抛出的异常是不是 A 会回滚的异常)。 PROPAGATION_SUPPORTS假设 ServiceB.MethodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.MethodB()时，如果发现 ServiceA.MethodA()已经开启了一个事务，则加入当前的事务，如果发现 ServiceA.MethodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。 PROPAGATION_NESTED现在的情况就变得比较复杂了, ServiceB.MethodB()的事务属性被配置为PROPAGATION_NESTED, 此时两者之间又将如何协作呢? ServiceB.MethodB() 如果 rollback, 那么内部事务(即 ServiceB.MethodB()) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA.MethodA()) 可以有以下两种处理方式: 捕获异常，执行异常分支逻辑 1234567void MethodA() { try { ServiceB.MethodB(); } catch (SomeException) { // 执行其他业务, 如 ServiceC.MethodC(); } } 这种方式也是嵌套事务最右价值的地方, 它起到了分之执行的效果, 如果ServiceB.MethodB()失败, 那么执行 ServiceC.MethodC(), 而 ServiceB.MethodB() 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。 外部事务回滚/提交 代码不做任何修改 那么如果内部事务(ServiceB.MethodB()) rollback, 那么首先 ServiceB.MethodB() 回滚到它执行之前的SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA.MethodA()) 将根据具体的配置决定自己是commit 还是 rollback。 浅谈分布式事务现今互联网界，分布式系统和微服务架构盛行。一个简单操作，在服务端非常可能是由多个服务和数据库实例协同完成的。在一致性要求较高的场景下，多个独立操作之间的一致性问题显得格外棘手。 基于水平扩容能力和成本考虑，传统的强一致的解决方案（e.g.单机事务）纷纷被抛弃。 其理论依据就是响当当的 CAP 原理。往往为了可用性和分区容错性，忍痛放弃强一致支持，转而追求最终一致性。 分布式系统的特性在分布式系统中，同时满足 CAP 定律中的一致性 Consistency、可用性 Availability 和分区容错性 Partition Tolerance 三者是不可能的。在绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。 分布式事务服务（Distributed Transaction Service，DTS）是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。 CAP 理论告诉我们在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络 硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的，所以我们只能在一致性和可用性之间进行权衡。 为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。 数据一致性 强一致性 : 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。 根据 CAP 理论，这种实现需要牺牲可用性。 弱一致性 : 系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。 最终一致性 : 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟， 系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。","link":"/2019/08/27/Spring-2019-08-Spring事务/"},{"title":"Spring源码分析","text":"Spring初探全文参考Spring官方文档： https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/index.html 一、Spring5 框架介绍 核心容器由spring-beans、spring-core、spring-context和spring-expression（Spring Expression Language, SpEL） 4 个模块组成。spring-core 和 spring-beans 模块是 Spring 框架的核心模块，包含了控制反转（Inversion ofControl, IOC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是 Spring 框架中的核心接口，它是工厂模式的具体实现。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-context 模块构架于核心模块之上，他扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，她的超类是 BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。 spring-context-support 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。 spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。 spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计，他可以非常方便地同 Spring IOC 进行交互。 AOP 和设备支持由 spring-aop、spring-aspects 和 spring-instrument 3 个模块组成。 spring-aop 是 Spring 的另一个核心模块，是 AOP 主要的实现模块。作为继 OOP 后，对程序员影 响最大的编程思想之一，AOP 极大地开拓了人们对于编程的思路。在 Spring 中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的 AOP 横切实现，比如前置通知、返回通知、异常通知等，同时，Pointcut 接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求 进行切入。 spring-aspects 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。 spring-instrument 模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP 的一个支援模块，主要作用是在 JVM 启用时，生成一个代理类，程序员通过代理类在运行时修改类的 字节，从而改变一个类的功能，实现 AOP 的功能。在分类里，我把他分在了 AOP 模块下，在 Spring 官 方文档里对这个地方也有点含糊不清，这里是纯个人观点。 数据访问与集成由 spring-jdbc、spring-tx、spring-orm、spring-jms 和 spring-oxm 5 个模块组成。 spring-jdbc 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。 主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程， 主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。 spring-tx 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架，它对事务做了很好的封装， 通过它的 AOP 配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用 JDBC 事务控 制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法； 如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计 则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所 以，在使用 Spring JDBC 事务控制时，应该注意其特殊性。 spring-orm 模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和 Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。 spring-oxm 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写， 它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象），例如： JAXB, Castor, XMLBeans, JiBX 和 XStream 等。 spring-jms 模块（Java Messaging Service）能够发送和接收信息，自 Spring Framework 4.1 以 后，他还提供了对 spring-messaging 模块的支撑。 Web 组件由 spring-web、spring-webmvc、spring-websocket 和 spring-webflux 4 个模块组成。 spring-web 模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或 者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持。 spring-webmvc 模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC （model-view-Controller）的 Web 应用。 spring-websocket 模块主要是与 Web 前端的全双工通讯的协议。 spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。 集成测试即 spring-test 模块，主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。 集成兼容即 spring-framework-bom 模块，Bill of Materials.解决 Spring 的不同模块依赖版本不同问题。 各模块之间的依赖关系 Spring 版本命名规则 描述方式 说明 含义 Snapshot 快照版 尚不不稳定、尚处于开发中的版本 Release 稳定版 功能相对稳定，可以对外发行，但有时间限制 GA 正式版 代表广泛可用的稳定版(General Availability) M 里程碑版 (M 是 Milestone 的意思）具有一些全新的功能或是具有里程碑意义 的版本。 RC 终测版 Release Candidate（最终测试），即将作为正式版发布。","link":"/2019/08/12/Spring-2019-08-Spring源码初探/"},{"title":"渐入Spring-MVC","text":"Spring MVC 初体验初探 Spring MVC 请求处理流程Spring MVC 相对于前面的章节算是比较简单的，我们首先引用《Spring in Action》上的一张图来了解 Spring MVC 的核心组件和大致处理流程： 从上图中看到 ①、DispatcherServlet 是 SpringMVC 中的前端控制器(Front Controller),负责接收 Request 并将 Request 转发给对应的处理组件。② 、 HanlerMapping 是 SpringMVC 中 完 成 url 到 Controller 映 射 的 组 件 。DispatcherServlet 接收 Request,然后从 HandlerMapping 查找处理 Request 的Controller。③、Controller 处理 Request,并返回 ModelAndView 对象,Controller 是 SpringMVC中负责处理 Request 的组件(类似于 Struts2 中的 Action),ModelAndView 是封装结果视图的组件。④、⑤、⑥视图解析器解析 ModelAndView 对象并返回对应的视图给客户端。容器初始化时会建立所有 url 和 Controller 中的Method 的对应关系，保存到 HandlerMapping 中，用户请求是根据 Request 请求的url 快速定位到 Controller 中的某个方法。在 Spring 中先将 url 和 Controller 的对应关系,保存到 Map&lt;url,Controller&gt;中。Web 容器启动时会通知 Spring 初始化容器(加载Bean 的定义信息和初始化所有单例 Bean),然后 SpringMVC 会遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 url，然后将 url 和 Controller 保存到一个 Map中；这样就可以根据 Request 快速定位到 Controller，因为最终处理 Request 的是Controller 中的方法，Map 中只保留了 url 和 Controller 中的对应关系，所以要根据Request 的 url 进一步确认 Controller 中的 Method，这一步工作的原理就是拼接Controller 的 url(Controller 上@RequestMapping 的值)和方法的 url(Method 上@RequestMapping 的值)，与 request 的 url 进行匹配，找到匹配的那个方法；确定处理请求的 Method 后，接下来的任务就是参数绑定，把 Request 中参数绑定到方法的形式参数上，这一步是整个请求处理过程中最复杂的一个步骤。 Spring MVC 九大组件HandlerMappingsHandlerMapping 是用来查找 Handler 的，也就是处理器，具体的表现形式可以是类也可以是方法。比如，标注了@RequestMapping 的每个 method 都可以看成是一个Handler，由 Handler 来负责实际的请求处理。 HandlerMapping 在请求到达之后，它的作用便是找到请求相应的处理器 Handler 和 Interceptors。 HandlerAdapters从名字上看，这是一个适配器。因为 Spring MVC 中 Handler 可以是任意形式的，只要能够处理请求便行, 但是把请求交给 Servlet 的时候，由于 Servlet 的方法结构都是如doService(HttpServletRequest req, HttpServletResponse resp) 这样的形式，让固定的 Servlet 处理方法调用 Handler 来进行处理，这一步工作便是 HandlerAdapter 要做的事。 HandlerExceptionResolvers从这个组件的名字上看，这个就是用来处理 Handler 过程中产生的异常情况的组件。 具体来说，此组件的作用是根据异常设置 ModelAndView, 之后再交给 render()方法进行渲 染 ， 而 render() 便 将 ModelAndView 渲 染 成 页 面 。 不 过 有 一 点 ，HandlerExceptionResolver 只是用于解析对请求做处理阶段产生的异常，而渲染阶段的异常则不归他管了，这也是 Spring MVC 组件设计的一大原则分工明确互不干涉。 ViewResolvers视图解析器，相信大家对这个应该都很熟悉了。因为通常在 SpringMVC 的配置文件中，都会配上一个该接口的实现类来进行视图的解析。 这个组件的主要作用，便是将 String类型的视图名和Locale解析为View类型的视图。这个接口只有一个resolveViewName()方法。从方法的定义就可以看出，Controller 层返回的 String 类型的视图名 viewName，最终会在这里被解析成为 View。View 是用来渲染页面的，也就是说，它会将程序返回的参数和数据填入模板中，最终生成 html 文件。ViewResolver 在这个过程中，主要做两件大事，即，ViewResolver 会找到渲染所用的模板（使用什么模板来渲染？）和所用的技术（其实也就是视图的类型，如 JSP 啊还是其他什么 Blabla 的）填入参数。默认情况下，Spring MVC 会为我们自动配置一个 InternalResourceViewResolver，这个是针对 JSP 类型视图的。 RequestToViewNameTranslator这个组件的作用，在于从 Request 中获取 viewName. 因为ViewResolver 是根据ViewName 查找 View, 但有的 Handler 处理完成之后，没有设置 View 也没有设置ViewName， 便要通过这个组件来从 Request 中查找 viewName。 LocaleResolver在上面我们有看到 ViewResolver 的 resolveViewName()方法，需要两个参数。那么第二个参数 Locale 是从哪来的呢，这就是 LocaleResolver 要做的事了。 LocaleResolver用于从 request 中解析出 Locale, 在中国大陆地区，Locale 当然就会是 zh-CN 之类，用来表示一个区域。这个类也是 i18n 的基础。 ThemeResolver从名字便可看出，这个类是用来解析主题的。主题，就是样式，图片以及它们所形成的显示效果的集合。Spring MVC 中一套主题对应一个 properties 文件，里面存放着跟当前主题相关的所有资源，如图片，css 样式等。创建主题非常简单，只需准备好资源，然后新建一个 “主题名.properties” 并将资源设置进去，放在 classpath 下，便可以在页面中使用了。 Spring MVC 中跟主题有关的类有 ThemeResolver, ThemeSource 和Theme。 ThemeResolver 负责从 request 中解析出主题名， ThemeSource 则根据主题名找到具体的主题， 其抽象也就是 Theme, 通过 Theme 来获取主题和具体的资源。 MultipartResolver其实这是一个大家很熟悉的组件，MultipartResolver 用于处理上传请求，通过将普通的Request 包装成 MultipartHttpServletRequest来实现。MultipartHttpServletRequest可以通过 getFile() 直接获得文件，如果是多个文件上传，还可以通过调用 getFileMap得到 Map&lt;FileName, File&gt; 这样的结构。MultipartResolver 的作用就是用来封装普通的 request，使其拥有处理文件上传的功能。 FlashMapManager说到 FlashMapManager，就得先提一下 FlashMap。FlashMap 用于重定向 Redirect 时的参数数据传递，比如，在处理用户订单提交时，为了避免重复提交，可以处理完 post 请求后 redirect 到一个 get 请求，这个 get 请求可以用来显示订单详情之类的信息。这样做虽然可以规避用户刷新重新提交表单的问题，但是在这个页面上要显示订单的信息，那这些数据从哪里去获取呢，因为 redirect 重定向是没有传递参数这一功能的，如果不想把参数写进 url(其实也不推荐这么做，url 有长度限制不说，把参数都直接暴露，感觉也不安全)， 那么就可以通过 flashMap 来传递。只需 要 在 redirect 之 前 ， 将 要 传 递 的 数 据 写 入 request （ 可 以 通 过ServletRequestAttributes.getRequest() 获 得 ） 的 属 性OUTPUT_FLASH_MAP_ATTRIBUTE 中，这样在 redirect 之后的 handler 中 Spring 就会自动将其设置到 Model 中，在显示订单信息的页面上，就可以直接从 Model 中取得数据了。而 FlashMapManager 就是用来管理 FlashMap 的。 Spring MVC 源码分析根据上面分析的 Spring MVC 工作机制，从三个部分来分析 Spring MVC 的源代码。其一，ApplicationContext 初始化时用 Map 保存所有 url 和 Controller 类的对应关系；其二，根据请求 url 找到对应的 Controller，并从 Controller 中找到处理请求的方法;其三，Request 参数绑定到方法的形参，执行方法处理请求，并返回结果视图。 初始化阶段我们首先找到 DispatcherServlet 这个类，必然是寻找 init()方法。然后，我们发现其 init方法其实在父类 HttpServletBean 中，其源码如下： 1234567891011121314151617181920212223242526272829303132public final void init() throws ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); } // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { //定位资源 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); //加载配置信息 ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); } throw ex; } } // Let subclasses do whatever initialization they like. initServletBean(); if (logger.isDebugEnabled()) { logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); }} FrameworkSERvlet实现了initServletBean() 123456789101112131415161718192021222324252627protected final void initServletBean() throws ServletException { getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) { this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); } long startTime = System.currentTimeMillis(); try { this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } catch (RuntimeException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); }} 这段代码中最主要的逻辑就是初始化 IOC 容器，最终会调用 refresh()方法，IOC 容器初始化之后，最后有调用了 onRefresh()方法。这个方法最终是在DisptcherServlet 中实现，来看源码： 123456789101112131415161718192021222324252627282930@Overrideprotected void onRefresh(ApplicationContext context) { initStrategies(context);}/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. *///初始化策略protected void initStrategies(ApplicationContext context) { //多文件上传的组件 initMultipartResolver(context); //初始化本地语言环境 initLocaleResolver(context); //初始化模板处理器 initThemeResolver(context); //handlerMapping initHandlerMappings(context); //初始化参数适配器 initHandlerAdapters(context); //初始化异常拦截器 initHandlerExceptionResolvers(context); //初始化视图预处理器 initRequestToViewNameTranslator(context); //初始化视图转换器 initViewResolvers(context); // initFlashMapManager(context);} 到这一步就完成了Spring MVC的九大组件的初始化。接下来，我们来看url和Controller的关系是如何建立的HandlerMapping 的子类AbstractDetectingUrlHandlerMapping 实现了 initApplicationContext()方法，所以我们直接看子类中的初始化容器方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void initApplicationContext() throws ApplicationContextException { super.initApplicationContext(); detectHandlers();}/** * Register all handlers found in the current ApplicationContext. * &lt;p&gt;The actual URL determination for a handler is up to the concrete * {@link #determineUrlsForHandler(String)} implementation. A bean for * which no such URLs could be determined is simply not considered a handler. * @throws org.springframework.beans.BeansException if the handler couldn't be registered * @see #determineUrlsForHandler(String) *//** * 建立当前ApplicationContext中的所有controller和url的对应关系 */protected void detectHandlers() throws BeansException { ApplicationContext applicationContext = obtainApplicationContext(); if (logger.isDebugEnabled()) { logger.debug(\"Looking for URL mappings in application context: \" + applicationContext); } // 获取ApplicationContext容器中所有bean的Name String[] beanNames = (this.detectHandlersInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) : applicationContext.getBeanNamesForType(Object.class)); // Take any bean name that we can determine URLs for. // 遍历beanNames,并找到这些bean对应的url for (String beanName : beanNames) { // 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现 String[] urls = determineUrlsForHandler(beanName); if (!ObjectUtils.isEmpty(urls)) { // URL paths found: Let's consider it a handler. // 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现 registerHandler(urls, beanName); } else { if (logger.isDebugEnabled()) { logger.debug(\"Rejected bean name '\" + beanName + \"': no URL paths identified\"); } } }}/** * Determine the URLs for the given handler bean. * @param beanName the name of the candidate bean * @return the URLs determined for the bean, or an empty array if none *//** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/protected abstract String[] determineUrlsForHandler(String beanName); determineUrlsForHandler(String beanName)方法的作用是获取每个 Controller 中的url，不同的子类有不同的实现，这是一个典型的模板设计模式。因为开发中我们用的最多的就是用注解来配置 Controller 中的 url，BeanNameUrlHandlerMapping 是AbstractDetectingUrlHandlerMapping的子类,处理注解形式的url映射.所以我们这里以BeanNameUrlHandlerMapping进行分析我们看BeanNameUrlHandlerMapping 是如何查 beanName 上所有映射的 url。 12345678910111213protected String[] determineUrlsForHandler(String beanName) { List&lt;String&gt; urls = new ArrayList&lt;&gt;(); if (beanName.startsWith(\"/\")) { urls.add(beanName); } String[] aliases = obtainApplicationContext().getAliases(beanName); for (String alias : aliases) { if (alias.startsWith(\"/\")) { urls.add(alias); } } return StringUtils.toStringArray(urls);} 到这里 HandlerMapping 组件就已经建立所有 url 和 Controller 的对应关系。 运行调用阶段这一步步是由请求触发的，所以入口为 DispatcherServlet 的核心方法为 doService()，doService()中的核心逻辑由 doDispatch()实现，源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** 中央控制器,控制请求的转发 **/protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { // 1.检查是否是文件上传的请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 2.取得处理当前请求的controller,这里也称为hanlder,处理器, // 第一个步骤的意义就在这里体现了.这里并不是直接返回controller, // 而是返回的HandlerExecutionChain请求处理器链对象, // 该对象封装了handler和interceptors. mappedHandler = getHandler(processedRequest); // 如果handler为空,则返回404 if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // Determine handler adapter for the current request. //3. 获取处理request的处理器适配器handler adapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) { logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); } if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) { return; } } if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // Actually invoke the handler. // 4.实际的处理器处理请求,返回结果视图对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } // 结果视图对象的处理 applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); } processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion if (mappedHandler != null) { // 请求成功响应之后的方法 mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request. if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } }} getHandler(processedRequest)方法实际上就是从 HandlerMapping 中找到 url 和Controller 的对应关系。也就是 Map&lt;url,Controller&gt;。我们知道，最终处理 Request的是 Controller 中的方法，我们现在只是知道了 Controller，我们如何确认 Controller中处理 Request 的方法呢？继续往下看。 从 Map&lt;urls,beanName&gt;中取得 Controller 后，经过拦截器的预处理方法，再通过反射获取该方法上的注解和参数，解析方法和参数上的注解，然后反射调用方法获取ModelAndView 结果视图。最后，调用的就是RequestMappingHandlerAdapter 的handle()中的核心逻辑由 handleInternal(request, response, handler)实现。 123456789101112131415161718192021222324252627282930313233343536@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { ModelAndView mav; checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) { HttpSession session = request.getSession(false); if (session != null) { Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) { mav = invokeHandlerMethod(request, response, handlerMethod); } } else { // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); } } else { // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); } if (!response.containsHeader(HEADER_CACHE_CONTROL)) { if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) { applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); } else { prepareResponse(response); } } return mav;} 整个处理过程中最核心的逻辑其实就是拼接 Controller 的 url 和方法的 url，与 Request的 url 进行匹配，找到匹配的方法。 1234567891011121314151617181920212223@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception { String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); if (logger.isDebugEnabled()) { logger.debug(\"Looking up handler method for path \" + lookupPath); } this.mappingRegistry.acquireReadLock(); try { HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); if (logger.isDebugEnabled()) { if (handlerMethod != null) { logger.debug(\"Returning handler method [\" + handlerMethod + \"]\"); } else { logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\"); } } return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); } finally { this.mappingRegistry.releaseReadLock(); }} 通过上面的代码分析，已经可以找到处理 Request 的 Controller 中的方法了，现在看如何解析该方法上的参数，并反射调用该方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** 获取处理请求的方法,执行并返回结果视图 **/@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { ServletWebRequest webRequest = new ServletWebRequest(request, response); try { WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) { invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); } if (this.returnValueHandlers != null) { invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); } invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) { Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); if (logger.isDebugEnabled()) { logger.debug(\"Found concurrent result value [\" + result + \"]\"); } invocableMethod = invocableMethod.wrapConcurrentResult(result); } invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) { return null; } return getModelAndView(mavContainer, modelFactory, webRequest); } finally { webRequest.requestCompleted(); }} 123456789101112131415161718192021222324252627282930public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) { if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) { mavContainer.setRequestHandled(true); return; } } else if (StringUtils.hasText(getResponseStatusReason())) { mavContainer.setRequestHandled(true); return; } mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, \"No return value handlers\"); try { this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); } catch (Exception ex) { if (logger.isTraceEnabled()) { logger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex); } throw ex; }} invocableMethod.invokeAndHandle()最终要实现的目的就是：完成 Request 中的参数和方法参数上数据的绑定。Spring MVC 中提供两种 Request 参数到方法中参数的绑定方式： 通过注解进行绑定，@RequestParam。 通过参数名称进行绑定。 使用注解进行绑定，我们只要在方法参数前面声明@RequestParam(&quot;name&quot;)，就可以将 request 中参数 name 的值绑定到方法的该参数上。使用参数名称进行绑定的前提是必须要获取方法中参数的名称，Java 反射只提供了获取方法的参数的类型，并没有提供获取参数名称的方法。SpringMVC 解决这个问题的方法是用 asm 框架读取字节码文件，来获取方法的参数名称。asm 框架是一个字节码操作框架，关于 asm 更多介绍可以参考其官网。个人建议，使用注解来完成参数绑定，这样就可以省去 asm 框架的读取字节码的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) { logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"' with arguments \" + Arrays.toString(args)); } Object returnValue = doInvoke(args); if (logger.isTraceEnabled()) { logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"] returned [\" + returnValue + \"]\"); } return returnValue;}/** * Get the method argument values for the current request. */private Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { MethodParameter[] parameters = getMethodParameters(); Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) { MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = resolveProvidedArgument(parameter, providedArgs); if (args[i] != null) { continue; } if (this.argumentResolvers.supportsParameter(parameter)) { try { args[i] = this.argumentResolvers.resolveArgument( parameter, mavContainer, request, this.dataBinderFactory); continue; } catch (Exception ex) { if (logger.isDebugEnabled()) { logger.debug(getArgumentResolutionErrorMessage(\"Failed to resolve\", i), ex); } throw ex; } } if (args[i] == null) { throw new IllegalStateException(\"Could not resolve method parameter at index \" + parameter.getParameterIndex() + \" in \" + parameter.getExecutable().toGenericString() + \": \" + getArgumentResolutionErrorMessage(\"No suitable resolver for\", i)); } } return args;} 到这里,方法的参数值列表也获取到了,就可以直接进行方法的调用了。整个请求过程中最复杂的一步就是在这里了。到这里整个请求处理过程的关键步骤都已了解。理解了Spring MVC 中的请求处理流程,整个代码还是比较清晰的。最后我们再来梳理一下Spring MVC 核心组件的关联关系（如下图）：","link":"/2019/08/25/Spring-2019-08-渐入Spring-MVC/"},{"title":"初识Spring-IOC、DI、AOP","text":"IOC(Inversion of Control)控制反转所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。 常用注解 @Component ：组件通用注解，常用于Model类 @Controller ：常用于对Controller实现类进行标注 @Service：常用于对Service实现类进行标注 @Repository：常用于对DAO实现类进行标注 DI(Dependency Injection)依赖注入指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。 常用注解 @Value ：注入普通类型属性 @Resource ：注入对象类型 @Autowired ：注入对象类型，默认按照类型注入。结合@Qualifier注解完成按名称的注入。 Aop(aspect object programming)面向切面编程AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向切面编程。可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP设计模式孜孜不倦追求的是调用者和被调用者之间的解耦，AOP 可以说也是这种目标的一种实现。我们现在做的一些非业务，如：日志、事务、安全等都会写在业务代码中(也即是说，这些非业务类横切于业务类)，但这些代码往往是重复，复制——粘贴式的代码会给程序的维护带来不便, AOP 就实现了把这些业务需求与系统需求分开来做。这种解决的方式也称代理机制。 AOP 中必须明白的几个概念 切面（Aspect） 官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。“切面”在ApplicationContext 中aop:aspect来配置。 连接点（Joinpoint） 程序执行过程中的某一行为，例如，MemberService .get 的调用或者 MemberService .delete 抛出异常等行为。 通知（Advice） “切面”对于某个“连接点”所产生的动作。其中，一个“切面”可以包含多个“Advice”。 切入点（Pointcut） 匹配连接点的断言，在 AOP 中通知和一个切入点表达式关联。切面中的所有通知所关注的连接点，都由切入点表达式来决定。 目标对象（Target Object） 被一个或者多个切面所通知的对象。例如，AServcieImpl 和 BServiceImpl，当然在实际运行时，Spring AOP 采用代理实现，实际 AOP 操作的是 TargetObject 的代理对象。 AOP 代理（AOP Proxy） 在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLib 代理。默认情况下，TargetObjec实现了接口时，则采用 JDK 动态代理，例如，AServiceImpl；反之，采用 CGLib 代理，例如，BServiceImpl。 强制使用 CGLib 代理需要将 aop:config的 proxy-target-class 属性设为 true。 通知类型 前置通知（Before Advice） 在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在aop:aspect里面使用aop:before元素进行声明。例如，TestAspect 中的 doBefore 方法。 后置通知（After Advice） 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在 aop:aspect里面使用aop:after元素进行声明。例如，ServiceAspect 中的 returnAfter 方法，所 以 Teser 中调用 UserService.delete 抛出异常时，returnAfter 方法仍然执行。 返回后通知（After Return Advice） 在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在aop:aspect 里面使用元素进行声明。 环绕通知（Around Advice） 包围一个连接点的通知，类似 Web 中 Servlet 规范中的 Filter 的 doFilter 方法。可以在方法的调用前 后完成自定义的行为，也可以选择不执行。ApplicationContext 中在aop:aspect里面使用 aop:around元素进行声明。例如，ServiceAspect 中的 around 方法。 异常通知（After Throwing Advice） 在 方 法 抛 出 异 常 退 出 时 执 行 的 通 知 。 ApplicationContext 中 在 aop:aspect 里 面 使 用 aop:after-throwing元素进行声明。例如，ServiceAspect 中的 returnThrow 方法。 注：可以将多个通知应用到一个目标对象上，即可以将多个切面织入到同一目标对象。 基于XML的注入方式1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\"?&gt;&lt;beans xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns=\"http://www.springframework.org/schema/beans\"&gt; &lt;!-- 注解驱动加上这句话 --&gt; &lt;!--&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;--&gt; &lt;bean class=\"com.xxx.xxx.aop.aspect.XmlAspect\" id=\"xmlAspect\"/&gt; &lt;!--AOP配置 --&gt; &lt;aop:config&gt; &lt;!--声明一个切面,并注入切面Bean,相当于@Aspect --&gt; &lt;aop:aspect ref=\"xmlAspect\"&gt; &lt;!--配置一个切入点,相当于@Pointcut --&gt; &lt;aop:pointcut id=\"simplePointcut\" expression=\"execution(* com.xxx.xxx.aop.service..*(..))\"/&gt; &lt;!--配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt; &lt;aop:before method=\"before\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after-returning method=\"afterReturn\" pointcut-ref=\"simplePointcut\"/&gt; &lt;aop:after-throwing method=\"afterThrow\" pointcut-ref=\"simplePointcut\" throwing=\"ex\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"simplePointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 基于注解的AOP12345678910111213141516171819202122232425262728293031//声明这是一个组件@Component//声明这是一个切面Bean@Aspectpublic class ArgsAspect { private final static Logger log = Logger.getLogger(ArgsAspect.class); //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点 @Pointcut(\"execution(* com.xxx.xxx.aop.service..*(..))\") public void aspect(){ } //配置前置通知,拦截返回值为com.xxx.xxx.model.Member的方法 @Before(\"execution(com.xxx.xxx.model.Member com.gupaoedu.vip.aop.service..*(..))\") public void beforeReturnUser(JoinPoint joinPoint){ log.info(\"beforeReturnUser \" + joinPoint); } //配置前置通知,拦截参数为com.xxx.xxx.model.Member的方法 @Before(\"execution(* com.xxx.xxx.aop.service..*(com.xxx.xxx.model.Member))\") public void beforeArgUser(JoinPoint joinPoint){ log.info(\"beforeArgUser \" + joinPoint); } //配置前置通知,拦截含有long类型参数的方法,并将参数值注入到当前方法的形参id中 @Before(\"aspect()&amp;&amp;args(id)\") public void beforeArgId(JoinPoint joinPoint, long id){ log.info(\"beforeArgId \" + joinPoint + \"\\tID:\" + id); } } 附: 基于注解开发的细节 引入约束 1234567&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 开启注解扫描 12&lt;context:component-scan base-package=\"com.xxx.xxx\"/&gt;&lt;context:annotation-config /&gt; 其他附加属性 @Scope ：在类上添加的，控制类生成的时候采用单例还是多例。取值： singleton ：单例prototype ：多例request ：request域，需要在web环境session ：session域，需要在web环境application： context域，需要在web环境globalsession 集群环境的session域，需要在web环境 @PostConstruct ：Bean生命周期中的初始化阶段执行,相当于init-method @PreDestroy ：Bean生命周期中的销毁阶段执行,相当于destroy-method","link":"/2019/08/21/Spring-2019-08-初识Spring-IOC、DI、AOP/"},{"title":"Linux学习（三）：管道和链接","text":"管道和链接1.|管道 ls -l / | more 一个命令的输出可以通过管道交给另一个命令的输出 2.ln链接 软链接：软链接不占用磁盘空间，源文件删除则软链接失效。 ln -s 源文件 链接文件 注意：如果软链接文件和源文件不在统一目录，源文件要使用绝对路径，不能使用相对路径，因为软链接只会记录路径名称。 硬链接：硬链接只能链接普通文件，不能链接目录。本身占用空间，与源文件同步发生变化，使用ll查看文件时，有一个数字，代表有几个文件能同步发生变化。 ln 源文件 链接文件","link":"/2019/05/06/linux-2019-05-Linux学习（三）：管道和链接/"},{"title":"Linux学习（二）：权限及通配符","text":"ls 查看权限执行touch a 新建文件a,执行命令 ll -h查看列表文件a的详细信息（下面用作例子详细介绍） -rw-rw-r–. 1 test test 0 1月 4 11:11 a 解读\\列名 权限 硬件链接数 文件属主 文件所属的组 文件大小 文件修改时间 文件名 信息 -rw-rw-r–. 1 test test 0 1月 4 11:11 a 详解1 第一个字符[-d]，d代表文件夹，-代表文件 - - - - - - 详解2 第一个字符后9个字符分为三组[-rwx][-rwx][-rwx]。r代表可读，w代表可写，x代表可执行-代表非。 - - - - - - 详解3 三组[-rwx][-rwx][-rwx]中。第一组：当前用户的权限，第二组：当前用户组对文件的权限，第三组：其他用户组的权限 - - - - - - 文件夹ceshi的详细信息 drwxrwxr-x. 2 test test 6 1月 4 11:10 ceshi chmod设置权限1.chmod字母法 语 法： chmod [ugoa] [+-=] [rwx] 文件demo：chmod u+x test.txt 给文件拥有者添加可执行权限 u:user表示文件所有者 g：group 表示文件所有者属于同一组（group）者，即用户组 o：other表示其他人 a：All 表示所有人 +：增加权限 -：撤销权限 =：设定权限 r：red 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容 w：write表示可写入，对于一个目录，如果没有w权限，那么就意味着不能再目录下创建文件 x：excute 表示可执行，对于一个目录，如果没有x权限，就意味着不能通过cd进入这个目录。 2.chmod数字法 语 法：chmod [124][124][124] 文件 数字 说明 4 r 读取权限 2 w 写入权限 1 x 执行权限 0 - 不具任何权限 demo：chmod 123 a.txt 第一位数字代表自己的权限 第二位数字代表自己组的权限 第三位数字代表其他人的权限 3 =1+2 代表w+x 通配符 通配符 含义 * 代表文件名中所有字符 ls te* 查找以te开头的文件 ls *html 查找html结尾的文件 ？ 代表文件名任意一个字符 ls ?.c 只找第一个字符任意，后缀为.c的文件 [abc] 匹配abc中任意一个 [a-f] 匹配从a到f 范围内的任意一个字符 ls [a-f]* 找到从a到f范围内的任意一个字符开头的文件 ls a-f 找到名字为a-f的文件，当-处于[]之外失去通配符的作用 \\ 转义字符","link":"/2019/05/06/linux-2019-05-Linux学习（二）：权限及通配符/"},{"title":"Linux学习（一）：命令基本使用","text":"常用Linux命令的基本使用1.cd 切换文件夹（change directory） cd /home绝对路径，以根目录开头 cd admin相对路径，不以根目录开头 cd .. 返回上一级目录 cd ~ 到自己家的目录（/home/admin） cd - 在当前目录和最近的一个历史操作目录切换 2.pwd 查看当前目录所在路径（print wrok directory）3.ls 查看当前目录内容（list） ls -l 显示详细列表 ls -lh 把文件大小以人性化的方式显示 ls -a 显示所有文件，包含隐藏文件，隐藏文件是.开头的文件 ll 等于ls -l 命令可组合使用，比如ll -a 、ls -hla。 -后面的关键词顺序不固定 4.mkdir 创建目录（make directory） mkdir test 在当前目录创建文件夹取名“test” mkdir /home/admin/test 在绝对路径创建文件夹 mkdir /home/admin/a/test -p 如果上级目录不存在，加上-p自动创建目录 mkdir test1 test2 在当前目录创建多个文件夹 mkdir a/{b,c} 在指定目录下创建多个文件夹 mkdir .test 以.开头创建隐藏文件夹 每个目录下都有.、.. 两个隐藏目录 5.touch 如果文件不存在，新建文件（touch） touch abc.txt 在当前目录下创建，如果指定了目录，必须保证上级目录存在 touch .abc 创建隐藏文件 gedit abc.txt 打开文件进行编辑，如果文件不存在则创建文件 6.rm 删除指定文件名（remove） rm a.txt 删除文件 rm abc -r 删除文件夹 rm * -r 删除所有文件和文件夹（不能删除隐藏文件） 7.clear 清屏（clear）8.cp 拷贝文件（copy） cp a.txt b.txt 拷贝源文件a.txt到目标文件b.txt cp abc abc_bak -r 拷贝文件夹 cp选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 不常用，默认会加上。覆盖已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 9.mv 移动/剪切、重命名（move） mv a.txt a 剪切a.txt到a文件夹下，如果要改名字修改后者路径即可 mv选项 含义 -f 禁止交互式操作，如果覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问用户回答以避免误覆盖文件 -v 显示移动进度 注意：mv对文件夹可以直接移动，不需要-r 10.&gt; 重定向 ls &gt; 1.txt 把ls命令返回的结果输出到文件中，会覆盖之前的数据，默认情况ls的返回结果是显示在屏幕中 ls&gt;&gt;1.txt把ls命令返回的结果输出到1.txt中，以追加的方式。 11.cat查看文件内容 cat 1.txt 把文件的内容全部显示到屏幕中 cat 1.txt 2.txt 把两个文件内容全部显示到屏幕中 cat 1.txt 2.txt &gt;3.txt把多个文件的内容合并到新的文件中 12.more查看文件内容，可以分页显示 more 1.txt 查看内容多的文件，按空格键往下翻页，按b键往回翻页，按enter下一行，按q键退出","link":"/2019/05/06/linux-2019-05-Linux学习（一）：命令基本使用/"},{"title":"渐入Spring-AOP","text":"Spring AOP源码分析一、寻找入口Spring 的 AOP 是通过接入 BeanPostProcessor 后置处理器开始的，它是 Spring IOC 容器经常使用到的一个特性，这个 Bean 后置处理器是一个监听器，可以监听容器触发的 Bean 声明周期事件。后置处理器向容器注册以后，容器中管理的 Bean 就具备了接收 IOC 容器事件回调的能力。 BeanPostProcessor 的使用非常简单，只需要提供一个实现接口 BeanPostProcessor 的实现类，然后在 Bean 的配置文件中设置即可。 1. BeanPostProcessor 源码123456789101112public interface BeanPostProcessor { //为在 Bean 的初始化前提供回调入口 @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } //为在 Bean 的初始化之后提供回调入口 @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} 这两个回调的入口都是和容器管理的 Bean 的生命周期事件紧密相关，可以为用户提供在 Spring IOC容器初始化 Bean 过程中自定义的处理操作。 2. AbstractAutowireCapableBeanFactory 类对容器生成的 Bean 添加后置处理器BeanPostProcessor 后置处理器的调用发生在 Spring IOC 容器完成对 Bean 实例对象的创建和属性的依赖注入完成之后，在对Spring依赖注入的源码分析过程中我们知道，当应用程序第一次调用getBean()方法(lazy-init 预实例化除外)向 Spring IOC 容器索取指定 Bean 时触发 Spring IOC 容器创建 Bean 实例对象并进行依赖注入的过程，其中真正实现创建 Bean 对象并进行依 赖注入的 方 法 是AbstractAutowireCapableBeanFactory 类的doCreateBean()方法，主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//真正创建Bean的方法protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. //封装被创建的Bean对象 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); //获取实例化对象的类型 Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. //调用PostProcessor后置处理器 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. //向容器中缓存单例模式的Bean对象，以防循环引用 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. //Bean对象的初始化，依赖注入在此触发 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean Object exposedObject = bean; try { //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象 populateBean(beanName, mbd, instanceWrapper); //初始化Bean对象 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { //获取指定名称的已注册的单例模式Bean对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { //根据名称获取的已注册的Bean和正在实例化的Bean是同一个 if (exposedObject == bean) { //当前实例化的Bean初始化完成 exposedObject = earlySingletonReference; } //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); //获取当前Bean所依赖的其他Bean for (String dependentBean : dependentBeans) { //对依赖Bean进行类型检查 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. //注册完成依赖注入的Bean try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject;} 从上面的代码中我们知道，为 Bean 实例对象添加 BeanPostProcessor 后置处理器的入口的是initializeBean()方法 3. initializeBean()方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器同样在 AbstractAutowireCapableBeanFactory 类中，initializeBean()方法实现为容器创建的 Bean实例对象添加 BeanPostProcessor 后置处理器，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { //JDK的安全机制验证权限 if (System.getSecurityManager() != null) { //实现PrivilegedAction接口的匿名内部类 AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { //为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; //对BeanPostProcessor后置处理器的postProcessBeforeInitialization //回调方法的调用，为Bean实例初始化前做一些处理 if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } //调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置 //文件中通过init-method属性指定的 try { invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } //对BeanPostProcessor后置处理器的postProcessAfterInitialization //回调方法的调用，为Bean实例初始化之后做一些处理 if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;}//调用BeanPostProcessor后置处理器实例对象初始化之前的处理方法public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { //调用Bean实例所有的后置处理中的初始化前处理方法，为Bean实例对象在 //初始化之前做一些自定义的处理操作 Object current = beanProcessor.postProcessBeforeInitialization(result, beanName); if (current == null) { return result; } result = current; } return result;} BeanPostProcessor 是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实现，在 Spring 中，BeanPostProcessor 的实现子类非常的多，分别完成不同的操作，如：AOP 面向切面编程的注册通知适配器、Bean 对象的数据校验、Bean 继承属性、方法的合并等等，我们以最简单的AOP 切面织入来简单了解其主要的功能。下面我们来分析其中一个创建 AOP 代理对象的子类AbstractAutoProxyCreator 类。该类重写了 postProcessAfterInitialization()方法。 二、选择代理策略进入 postProcessAfterInitialization()方法，我们发现调到了一个非常核心的方法wrapIfNecessary()，其源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 @Overridepublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean;}protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;}protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,@Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) { if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } return proxyFactory.getProxy(getProxyClassLoader());} 整个过程跟下来，我发现最终调用的是 proxyFactory.getProxy()方法。到这里我们大概能够猜到proxyFactory 有 JDK 和 CGLib 的，那么我们该如何选择呢？最终调用的是DefaultAopProxyFactory的 createAopProxy()方法： 12345678910111213141516171819202122232425262728293031public class DefaultAopProxyFactory implements AopProxyFactory, Serializable { @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\"TargetSource cannot determine target class: \" + \"Either an interface or a target is required for proxy creation.\"); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } /** * Determine whether the supplied {@link AdvisedSupport} has only the * {@link org.springframework.aop.SpringProxy} interface specified * (or no proxy interfaces specified at all). */ private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) { Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces(); return (ifcs.length == 0 || (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0]))); }} 三、调用代理方法分析调用逻辑之前先上类图，看看 Spring 中主要的 AOP 组件： 上面我们已经了解到 Spring 提供了两种方式来生成代理方式有 JDKProxy 和 CGLib。下面我们来研究一下 Spring 如何使用 JDK 来生成代理对象，具体的生成代码放在JdkDynamicAopProxy 这个类中，直接上相关代码： 1234567891011121314/** * 获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) * 检查上面得到的接口中有没有定义 equals或者hashcode的接口 * 调用Proxy.newProxyInstance创建代理对象 */@Overridepublic Object getProxy(@Nullable ClassLoader classLoader) { if (logger.isDebugEnabled()) { //... } Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);} 通过注释我们应该已经看得非常明白代理对象的生成过程，此处不再赘述。下面的问题是，代理对象生成了，那切面是如何织入的? 我们知道 InvocationHandler 是 JDK 动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而从 JdkDynamicAopProxy 的源码我们可以看到这个类其实也实现了 InvocationHandler，下面我们分析 Spring AOP 是如何织入切面的，直接上源码看 invoke()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { MethodInvocation invocation; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Object target = null; try { //eqauls()方法，具目标对象未实现此方法 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) { // The target does not implement the equals(Object) method itself. return equals(args[0]); } //hashCode()方法，具目标对象未实现此方法 else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) { // The target does not implement the hashCode() method itself. return hashCode(); } else if (method.getDeclaringClass() == DecoratingProxy.class) { // There is only getDecoratedClass() declared -&gt; dispatch to proxy config. return AopProxyUtils.ultimateTargetClass(this.advised); } //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知 else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) { // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); } Object retVal; if (this.advised.exposeProxy) { // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; } // Get as late as possible to minimize the time we \"own\" the target, // in case it comes from a pool. //获得目标对象的类 target = targetSource.getTarget(); Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null); // Get the interception chain for this method. //获取可以应用到此方法上的Interceptor列表 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // Check whether we have any advice. If we don't, we can fallback on direct // reflective invocation of the target, and avoid creating a MethodInvocation. //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args) if (chain.isEmpty()) { // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); } else { // We need to create a method invocation... //创建MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. retVal = invocation.proceed(); } // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) { // Special case: it returned \"this\" and the return type of the method // is type-compatible. Note that we can't help if the target sets // a reference to itself in another returned object. retVal = proxy; } else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) { throw new AopInvocationException( \"Null return value from advice does not match primitive return type for: \" + method); } return retVal; } finally { if (target != null &amp;&amp; !targetSource.isStatic()) { // Must have come from TargetSource. targetSource.releaseTarget(target); } if (setProxyContext) { // Restore old proxy. AopContext.setCurrentProxy(oldProxy); } }} 主要实现思路可以简述为：首先获取应用到此方法上的通知链（Interceptor Chain）。如果有通知，则应用通知，并执行 JoinPoint；如果没有通知，则直接反射执行 JoinPoint。而这里的关键是通知链是如何获取的以及它又是如何执行的呢？现在来逐一分析。首先，从上面的代码可以看到，通知链是通过 1Advised.getInterceptorsAndDynamicInterceptionAdvice() 这个方法来获取的，我们来看下这个方法的实现逻辑： 12345678910public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method Method, @Nullable Class&lt;?&gt; targetClass){ MethodCacheKey cacheKey = new MethodCacheKey(Method); List&lt;Object&gt; cached = this.MethodCache.get(cacheKey); if (cached == null) { cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this, Method, targetClass); this.MethodCache.put(cacheKey, cached); } return cached;} 通过上面的源码我们可以看到，实际获取通知的实现逻辑其实是由AdvisorChainFactory 的getInterceptorsAndDynamicInterceptionAdvice()方法来完成的，且获取到的结果会被缓存。下面来分析getInterceptorsAndDynamicInterceptionAdvice()方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor, * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断 * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回. */ @Overridepublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) { // This is somewhat tricky... We have to process introductions first, // but we need to preserve order in the ultimate list. List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(config.getAdvisors().length); Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); //查看是否包含IntroductionAdvisor boolean hasIntroductions = hasMatchingIntroductions(config, actualClass); //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); for (Advisor advisor : config.getAdvisors()) { if (advisor instanceof PointcutAdvisor) { // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { //这个地方这两个方法的位置可以互换下 //将Advisor转化成Interceptor MethodInterceptor[] interceptors = registry.getInterceptors(advisor); //检查当前advisor的pointcut是否可以匹配当前方法 MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) { if (mm.isRuntime()) { // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList;} 这个方法执行完成后，Advised 中配置能够应用到连接点（JoinPoint）或者目标类（Target Object）的 Advisor 全部被转化成了 MethodInterceptor，接下来我们再看下得到的拦截器链是怎么起作用的。 123456789101112131415//如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)if (chain.isEmpty()) { // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);}else { // We need to create a method invocation... //创建MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. retVal = invocation.proceed();} 从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其 proceed()方法，触发拦截器链的执行，来看下具体代码: 123456789101112131415161718192021222324252627282930313233public Object proceed() throws Throwable { // We start with an index of -1 and increment early. //如果Interceptor执行完了，则执行joinPoint if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { return invokeJoinpoint(); } Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); //如果要动态匹配joinPoint if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; //动态匹配：运行时参数是否满足匹配条件 if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) { return dm.interceptor.invoke(this); } else { // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor return proceed(); } } else { // It's an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. //执行当前Intercetpor return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); }} 至此，通知链就完美地形成了。我们再往下来看 invokeJoinpointUsingReflection()方法，其实就是反射调用： 123456789101112131415161718192021public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) throws Throwable { // Use reflection to invoke the method. try { ReflectionUtils.makeAccessible(method); return method.invoke(target, args); } catch (InvocationTargetException ex) { // Invoked method threw a checked exception. // We must rethrow it. The client won't see the interceptor. throw ex.getTargetException(); } catch (IllegalArgumentException ex) { throw new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" + method + \"] on target [\" + target + \"]\", ex); } catch (IllegalAccessException ex) { throw new AopInvocationException(\"Could not access method [\" + method + \"]\", ex); }} Spring AOP 源码就分析到这儿, 下面是AOP时序图: 四、触发通知在为 AopProxy 代理对象配置拦截器的实现中，有一个取得拦截器的配置过程，这个过程是由 DefaultAdvisorChainFactory 实现的，这个工厂类负责生成拦截器链，在它的getInterceptorsAndDynamicInterceptionAdvice 方法中，有一个适配器和注册过程，通过配置 Spring 预先设计好的拦截器，Spring 加入了它对 AOP 实现的处理。 12345678910111213141516171819/** * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor, * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断 * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回. */@Overridepublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) { List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(config.getAdvisors().length); Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); //查看是否包含IntroductionAdvisor boolean hasIntroductions = hasMatchingIntroductions(config, actualClass); //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); //.... return interceptorList;} GlobalAdvisorAdapterRegistry 负责拦截器的适配和注册过程。 123456789101112131415161718192021222324public abstract class GlobalAdvisorAdapterRegistry { /** * Keep track of a single instance so we can return it to classes that request it. */ private static AdvisorAdapterRegistry instance = new DefaultAdvisorAdapterRegistry(); /** * Return the singleton {@link DefaultAdvisorAdapterRegistry} instance. */ public static AdvisorAdapterRegistry getInstance() { return instance; } /** * Reset the singleton {@link DefaultAdvisorAdapterRegistry}, removing any * {@link AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered} * adapters. */ static void reset() { instance = new DefaultAdvisorAdapterRegistry(); }} 而 GlobalAdvisorAdapterRegistry 起到了适配器和单例模式的作用，提供了一个DefaultAdvisorAdapterRegistry，它用来完成各种通知的适配和注册过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable { private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3); /** * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters. */ public DefaultAdvisorAdapterRegistry() { registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); registerAdvisorAdapter(new AfterReturningAdviceAdapter()); registerAdvisorAdapter(new ThrowsAdviceAdapter()); } @Override public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException { if (adviceObject instanceof Advisor) { return (Advisor) adviceObject; } if (!(adviceObject instanceof Advice)) { throw new UnknownAdviceTypeException(adviceObject); } Advice advice = (Advice) adviceObject; if (advice instanceof MethodInterceptor) { // So well-known it doesn't even need an adapter. return new DefaultPointcutAdvisor(advice); } for (AdvisorAdapter adapter : this.adapters) { // Check that it is supported. if (adapter.supportsAdvice(advice)) { return new DefaultPointcutAdvisor(advice); } } throw new UnknownAdviceTypeException(advice); } @Override public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException { List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) { interceptors.add((MethodInterceptor) advice); } for (AdvisorAdapter adapter : this.adapters) { if (adapter.supportsAdvice(advice)) { interceptors.add(adapter.getInterceptor(advisor)); } } if (interceptors.isEmpty()) { throw new UnknownAdviceTypeException(advisor.getAdvice()); } return interceptors.toArray(new MethodInterceptor[interceptors.size()]); } @Override public void registerAdvisorAdapter(AdvisorAdapter adapter) { this.adapters.add(adapter); }} DefaultAdvisorAdapterRegistry 设置了一系列的是配置，正是这些适配器的实现，为Spring AOP 提供了编织能力。下面以 MethodBeforeAdviceAdapter 为例，看具体的实现： 1234567891011121314class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable { @Override public boolean supportsAdvice(Advice advice) { return (advice instanceof MethodBeforeAdvice); } @Override public MethodInterceptor getInterceptor(Advisor advisor) { MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); }} Spring AOP 为了实现 advice 的织入，设计了特定的拦截器对这些功能进行了封装。我们接着看 MethodBeforeAdviceInterceptor 如何完成封装的？ 1234567891011121314public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable { private MethodBeforeAdvice advice; public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) { Assert.notNull(advice, \"Advice must not be null\"); this.advice = advice; } @Override public Object invoke(MethodInvocation mi) throws Throwable { this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() ); return mi.proceed(); }} 可以看到，invoke 方法中，首先触发了 advice 的 before 回调，然后才是 proceed。AfterReturningAdviceInterceptor 的源码： 同理, AfterReturningAdviceInterceptor源码, 则先执行proceed: 12345678910111213141516171819202122public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable { private final AfterReturningAdvice advice; /** * Create a new AfterReturningAdviceInterceptor for the given advice. * @param advice the AfterReturningAdvice to wrap */ public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) { Assert.notNull(advice, \"Advice must not be null\"); this.advice = advice; } @Override public Object invoke(MethodInvocation mi) throws Throwable { Object retVal = mi.proceed(); this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis()); return retVal; }} ThrowsAdviceInterceptor 的源码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice { private static final String AFTER_THROWING = \"afterThrowing\"; private static final Log logger = LogFactory.getLog(ThrowsAdviceInterceptor.class); private final Object throwsAdvice; /** Methods on throws advice, keyed by exception class */ private final Map&lt;Class&lt;?&gt;, Method&gt; exceptionHandlerMap = new HashMap&lt;&gt;(); public ThrowsAdviceInterceptor(Object throwsAdvice) { Assert.notNull(throwsAdvice, \"Advice must not be null\"); this.throwsAdvice = throwsAdvice; Method[] methods = throwsAdvice.getClass().getMethods(); for (Method method : methods) { if (method.getName().equals(AFTER_THROWING) &amp;&amp; (method.getParameterCount() == 1 || method.getParameterCount() == 4) &amp;&amp; Throwable.class.isAssignableFrom(method.getParameterTypes()[method.getParameterCount() - 1]) ) { // Have an exception handler this.exceptionHandlerMap.put(method.getParameterTypes()[method.getParameterCount() - 1], method); if (logger.isDebugEnabled()) { logger.debug(\"Found exception handler method: \" + method); } } } if (this.exceptionHandlerMap.isEmpty()) { throw new IllegalArgumentException( \"At least one handler method must be found in class [\" + throwsAdvice.getClass() + \"]\"); } } public int getHandlerMethodCount() { return this.exceptionHandlerMap.size(); } @Nullable private Method getExceptionHandler(Throwable exception) { Class&lt;?&gt; exceptionClass = exception.getClass(); if (logger.isTraceEnabled()) { logger.trace(\"Trying to find handler for exception of type [\" + exceptionClass.getName() + \"]\"); } Method handler = this.exceptionHandlerMap.get(exceptionClass); while (handler == null &amp;&amp; exceptionClass != Throwable.class) { exceptionClass = exceptionClass.getSuperclass(); handler = this.exceptionHandlerMap.get(exceptionClass); } if (handler != null &amp;&amp; logger.isDebugEnabled()) { logger.debug(\"Found handler for exception of type [\" + exceptionClass.getName() + \"]: \" + handler); } return handler; } @Override public Object invoke(MethodInvocation mi) throws Throwable { try { return mi.proceed(); } catch (Throwable ex) { Method handlerMethod = getExceptionHandler(ex); if (handlerMethod != null) { invokeHandlerMethod(mi, ex, handlerMethod); } throw ex; } } private void invokeHandlerMethod(MethodInvocation mi, Throwable ex, Method method) throws Throwable { Object[] handlerArgs; if (method.getParameterCount() == 1) { handlerArgs = new Object[] { ex }; } else { handlerArgs = new Object[] {mi.getMethod(), mi.getArguments(), mi.getThis(), ex}; } try { method.invoke(this.throwsAdvice, handlerArgs); } catch (InvocationTargetException targetEx) { throw targetEx.getTargetException(); } }} 至此，我们知道了对目标对象的增强是通过拦截器实现的，最后还是上时序图:","link":"/2019/08/22/Spring-2019-08-渐入Spring-AOP/"},{"title":"Linux学习（五）：文件解压缩","text":"文件解压缩tar 归档 打包 打包 tar cvf a.tar 1.txt 2.txt ：f必须放到最后，f后面的第一个参数代表要生成的文件名，后面所有的参数是要打包的文件 tar tf a.tar ： 列出包里面的文件 解包 tar xvf a.tar 如果没有写目录，把包里面的文件解开放到当前目录 tar xvf a.tar -C tar 解压到指定文件夹，文件夹需要提前创建好 gzip 压缩文件 生成压缩文件 ① 打包tar cf a.tar * 生成a.tar② 压缩gzip -r a.tar 生成a.tar.gz文件 解压压缩文件 ① 解压gzip -d a.tar.gz 生成a.tar② 解包tar xf a.tar -C ~/atar 解包到指定文件夹中 一步到位打包并且压缩tar czf b.tar.gz *.txt 以gzip的方式打包并且压缩 一步到位解压并且解包tar zxf b.tar.gz -C btar 以gzip的方式解压缩并且解包 bzip2 压缩文件（用法同gzip） 压缩 tar jcf j.tar.bz2 *.txt 压缩文件 解压 tar xjf j.tar.bz2 -C jtar 解压文件 zip 压缩文件 压缩 zip -r zz *.txt zz 代表要生成的压缩文件，不需要写扩展名，会自动生成zip扩展名 解压 uzip -d zz zz.zip 解压时会自动创建目录 压缩率 zip&lt;gzip&lt;bzip2 通用性 zip&gt;gzip&gt;bzip2综合考虑：linux系统中一般使用gzip","link":"/2019/05/06/linux-2019-05-Linux学习（五）：文件解压缩/"},{"title":"Linux学习（六）：其他命令","text":"which 查看命令位置 which zip 查看zip命令的可执行文件所在位置，但无法查找cd这样的shell类型命令。 su 切换账号 su Centos下切换到root用户命令su test 切换到test用户 root切换其他用户不用输入密码，反之要输入密码。 passwd 重置密码 passwd 修改当前用户密码，密码有复杂度要求passwd test 切换到root后执行该命令，修改test用户密码，无强制要求密码复杂度 exit 退出当前用户 注意：如果使用su 登录root后再使用exit 只是退出root，当前窗口不会关闭。 who 查看当前登录的客户端，或者当前登录的命令终端 “pts”代表终端“tty”代表用户登录了操作系统pkill -kill -t tty1 杀死一个客户端连接 reboot、shutdown 重启、关机 命令 含义 reboot 重新启动操作系统 shutdown -r now 重启操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now代表时间为0的状态 shutdown -h 20:35 系统在今天的20:35会关机 shutdown -h +10 系统在十分钟之后自动关机 ，要取消则按ctrl+c","link":"/2019/05/06/linux-2019-05-Linux学习（六）：其他命令/"},{"title":"Linux学习（四）：四剑客之二（grep、find）","text":"linux四剑客grep 查找文件内容 grep hello test.txt 在某个文件中查找包含hello的内容，只要一行中有hello会把整行显示 grep -niv helle test.txt n显示查找到的内容行号，i查找时不区分大小写，v反向查找（查找不包含hello的行） grep -n hello home/admin -r 查找整个目录中的所有文件，包含hello的内容 find 查找文件 find /home -name 1.txt 在/home目录下查找文件名为1.txt的文件，输出文件路径 find /home -name '*.txt'在/home目录下查找所有后缀为.txt的文件。注意：如果查找模糊文件名，需对文件名参数加上引号。","link":"/2019/05/06/linux-2019-05-Linux学习（四）：四剑客之二（grep、find）/"},{"title":"设计模式（一）：单例模式","text":"单例模式的应用场景单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。 例如，国家主席、公司 CEO、部门经理等。在 J2EE标准中，ServletContext、 ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext；数据库的连接池也都是单例形式。 常见实现饿汉式单例：Spring中IOC容器ApplicationContext。 饿汉式单例饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题。 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。 12345678910111213public class HungrySingleton { //法1 private static final HungrySingleton instance = new HungrySingleton(); //法2 // static { // instance = new HungrySingleton(); // } private HungrySingleton() { } public static HungrySingleton getInstance(){ return instance; }} 懒汉式单例懒汉式单例的特点是：被外部类调用的时候内部类才会加载. 1.同步锁懒汉式单例1234567891011private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; public static LazyDoubleCheckSingleton getInstance(){ if(lazyDoubleCheckSingleton ==null){ synchronized(LazyDoubleCheckSingleton.class){ if(lazyDoubleCheckSingleton ==null){ lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); } } } return lazyDoubleCheckSingleton; } 2.内部类懒汉式单例123456789101112131415161718192021public class LazyInnerClassSingleton { private LazyInnerClassSingleton() { System.out.println(\"构造方法\"); if (LazyHolder.LAZY!=null){ throw new RuntimeException(\"禁止通过反射创建此单例对象\"); } } public static final LazyInnerClassSingleton getInstance(){ System.out.println(\"getInstance\"); return LazyHolder.LAZY; } /** * 内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。 */ private static class LazyHolder{ private static final LazyInnerClassSingleton LAZY= new LazyInnerClassSingleton(); } public static void main(String []s ){ LazyInnerClassSingleton.getInstance(); }} 注册式单例1.容器缓存注册式单例123456789101112131415161718192021222324252627282930public class ContainerSingleton { private ContainerSingleton() { } private static final Map&lt;String,Object&gt; instanceMap = new HashMap&lt;&gt;(); public static final Object getBean(String className){ if(className==null||\"\".equals(className.trim())) return null; synchronized(instanceMap){ if (instanceMap.containsKey(className)){ return instanceMap.get(className); }else{ Object obj = null; try { Class clazz = Class.forName(className); obj = clazz.newInstance(); instanceMap.put(className,obj); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } return obj; } } }} 2.枚举注册式单例此方法即使通过反序列化也能获得单例 123456789101112131415public enum EnumSingleton { INSTANCE; private Object data; public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static EnumSingleton getInstance(){ return INSTANCE; }}","link":"/2019/08/04/design-2019-08-设计模式（一）：单例模式/"},{"title":"设计模式（三）：装饰者模式","text":"装饰者模式定义装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对 象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。 装饰模式主要包含以下角色。 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 样例定义抽象构件 123public interface IComponent { void operation();} 实现具体构件 123456public class ConcreteComponent implements IComponent{ @Override public void operation() { System.out.println(\"执行基本操作~\"); }} 定义抽象装饰（抽象可选） 123456789101112public abstract class AbstDecorator implements IComponent{ private IComponent component; public AbstDecorator(IComponent component) { this.component = component; } @Override public void operation() { System.out.println(\"执行抽象装饰\"); component.operation(); }} 实现具体装饰 123456789101112131415public class ConcreteDecorator extends AbstDecorator { public ConcreteDecorator(IComponent component) { super(component); } @Override public void operation() { method1(); super.operation(); } public void method1(){ System.out.println(\"执行附加的装饰方法\"); }} 测试 1234567public class DecoratorTest { public static void main(String[] args) { IComponent component = new ConcreteComponent(); IComponent d1 = new ConcreteDecorator(component); d1.operation(); }} console打印如下： 执行附加的装饰方法执行抽象装饰执行基本操作~ jdk典型装饰者场景：InputStream 与适配器模式的区别 装饰者模式 适配器模式 形式 是一种特殊的适配器模式 没有层级关系，装饰者有层级关系 定义 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留OOP关系 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 关系 满足is-a的关系 满足has-a的关系 功能 注重覆盖、扩展 注重兼容、转换 设计 前置考虑 后置考虑（重构） 优缺点优点 装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。 装饰者完全遵守开闭原则。 缺点 会出现更多的代码，更多的类，增加程序复杂性。 动态装饰时，多层装饰时会更复杂。","link":"/2019/08/08/design-2019-08-设计模式（三）：装饰者模式/"},{"title":"设计模式（九）：观察者模式","text":"观察者模式定义观察者模式（Observer Pattern）定义了对象之间的一对多依赖，让多个观察者对象同 时监听一个主体对象，当主体对象发生变化时，它的所有依赖者（观察者）都会收到通 知并更新，属于行为型模式。观察者模式有时也叫做发布订阅模式。观察者模式主要用 于在关联行为之间建立一套触发机制的场景。 JDK 原生支持实现样例被观察者，也称发布者 1234567891011121314/** * 被观察者对象 * Created by miaozc on 2019-8-8. */public class ConcreteObservable extends Observable { /** * 发布一个事件 */ public void publishEvent(ObserveContext context){ setChanged(); System.out.println(\"发布一个事件\"+context.getName()); notifyObservers(context); }} 观察者，也称订阅者 1234567891011121314151617/** * 观察者 * Created by miaozc on 2019-8-8. */public class ConcreteObserver implements Observer { private String name ; public ConcreteObserver(String name) { this.name = name; } @Override public void update(Observable o, Object arg) { ConcreteObservable observable = (ConcreteObservable) o; ObserveContext context = (ObserveContext) arg; System.out.println(name+\"已接收到\"+context.getName()+\"的事件\"); }} 定义参数、上下文 123456789101112131415161718/** * 发布订阅上下文 * Created by miaozc on 2019-8-8. */public class ObserveContext { private String name; public ObserveContext(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 开始测试 123456789101112131415/** * 测试观察者 * Created by miaozc on 2019-8-8. */public class TestObserver { public static void main(String[] args) { ObserveContext context = new ObserveContext(\"Event 1\"); ConcreteObservable observable =new ConcreteObservable(); ConcreteObserver observer = new ConcreteObserver(\"观察者一号\"); ConcreteObserver observer2 = new ConcreteObserver(\"观察者二号\"); observable.addObserver(observer); observable.addObserver(observer2); observable.publishEvent(context); }} console打印结果： 发布一个事件Event 1观察者二号已接收到Event 1的事件观察者一号已接收到Event 1的事件 类图 原生的观察者模式是线程安全的。但在数据量大、多线程模式下，需要考虑性能问题。可以选择Object.notify()机制代替之。","link":"/2019/08/08/design-2019-08-设计模式（九）：观察者模式/"},{"title":"设计模式（七）：委派模式","text":"委派模式委派模式（Delegate Pattern）的基本作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。委派模式在 Spring 中应用非常多，大家常用的 DispatcherServlet 其实就是用到了委派模式。现实生活中也常有委 派的场景发生，例如：老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板。","link":"/2019/08/08/design-2019-08-设计模式（七）：委派模式/"},{"title":"设计模式（五）：模板方法模式","text":"模板方法模式定义模板模式通常又叫模板方法模式（Template Method Pattern）是指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤，属于行为性设计模式。模板方法适用于以下应用场景： 1、一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 2、各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。 示例 定义模板 12345678910111213public abstract class AbstTemplateMethod { public void templateMethod1(int p){ //抽象业务逻辑与模板逻辑灵活应用 p = p+10; p = method1(p); print(p); } abstract int method1(int p); private void print(int p){ System.out.println(p); }} 定义模板第一个业务类 1234567public class TemplateMethod1 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod1 p=\"); return p+1; }} 定义模板第二个业务类 1234567public class TemplateMethod2 extends AbstTemplateMethod{ @Override int method1(int p) { System.out.print(\"templateMethod2 p=\"); return p+2; }} 定义模板第n个业务类…. 测试 12345678public class TestTemplateMethod { public static void main(String[] args) { AbstTemplateMethod test = new TemplateMethod1(); test.templateMethod1(10); test = new TemplateMethod2(); test.templateMethod1(10); }}","link":"/2019/08/08/design-2019-08-设计模式（五）：模板方法模式/"},{"title":"设计模式（六）：原型模式","text":"原型模式简介 原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 调用者不需要知道任何创建细节 属于创建型模式 使用场景 类初始化小号资源较多 new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等） 构造函数比较复杂 循环体中产生大量对象时 常见原型模式工具类1BeanUtil.copy(); 1JSON.paseObject(); 1Guava 利用Java提供的Cloneable接口实现浅克隆123456public Object shallowClone(Test target){ Test test = new Test(); test.a = target.a;//普通字段 test.object = target.object;//对象字段，拷贝的是引用地址 return test;} 深克隆1234567891011121314151617181920public Object deepClone(){ try{ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); QiTianDaSheng copy = (QiTianDaSheng)ois.readObject(); copy.birthday = new Date(); return copy; }catch (Exception e){ e.printStackTrace(); return null; }finally{ ...close; }} 深克隆例子1ArrayList.clone();//ArrayList重写了clone方法","link":"/2019/08/08/design-2019-08-设计模式（六）：原型模式/"},{"title":"设计模式（八）：策略模式","text":"策略模式策略模式（Strategy Pattern）是指定义了算法家族、分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。 策略模式的应用场景1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。 2、一个系统需要动态地在几种算法中选择一种。 策略模式在 JDK 源码中的体现首先来看一个比较常用的比较器 Comparator 接口，我们看到的一个大家常用的compare()方法，就是一个策略抽象实现： 1234public interface Comparator&lt;T&gt; { int compare(T o1, T o2); ... } Comparator 抽象下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作为排序策略，例如 Arrays 类的 parallelSort 方法等： 1234567public class Arrays { ... public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; cmp) { ... } ... } 策略模式在 Spring 源码中的应用Spring 的初始化也采用了策略模式，不同的类型的类采用不同的初始化策略。 12345public interface InstantiationStrategy { Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, Constructor&lt;?&gt; var4, @Nullable Object... var5) throws BeansException; Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, @Nullable Object var4, Method var5, @Nullable Object... var6) throws BeansException; } 顶层的策略抽象非常简单，但是它下面有两种策略 SimpleInstantiationStrategy 和CglibSubclassingInstantiationStrategy 123public class SimpleInstantiationStrategy implements InstantiationStrategy { ...} 123public class CglibSubclassingInstantiationStrategy extends SimpleInstantiationStrategy { ...} 说明在实际应用中多种策略之间还可以继承使用 策略模式的优缺点优点： 1、策略模式符合开闭原则。 2、避免使用多重条件转移语句，如 if…else…语句、switch 语句 3、使用策略模式可以提高算法的保密性和安全性。 缺点： 1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。 2、代码中会产生非常多策略类，增加维护难度。","link":"/2019/08/08/design-2019-08-设计模式（八）：策略模式/"},{"title":"设计模式（四）：适配器模式","text":"适配器模式适配器模式（Adapter Pattern）是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作，属于结构型设计模式。 适配器适用于以下几种业务场景： 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。 生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。在中国民用电都是220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我们给手机充电时就需要使用电源适配器来进行转换。下面我们有代码来还原这个生活场 景，创建 AC220 类，表示 220V 交流电： 老版本逻辑 1234567public class AC220 { public int outputAC220V() { int output = 220; System.out.println(\"输出交流电\" + output + \"V\"); return output; }} 创建适配器接口 123public interface DC5 { int outputDC5V();} 创建适配器 123456789101112131415public class PowerAdapter implements DC5 { private AC220 ac220; public PowerAdapter(AC220 ac220) { this.ac220 = ac220; } @Override public int outputDC5V() { int adapterInput = ac220.outputAC220V(); //变压器 int adapterOutput = adapterInput / 44; System.out.println(\"使用 PowerAdapter 输入 AC:\" + adapterInput + \"V\" + \"输出 DC:\" + adapterOutput + \"V\"); return adapterOutput; }} 测试适配器 123456public class TestAdapter { public static void main(String[] args) { DC5 dc5 = new PowerAdapter(new AC220()); dc5.outputDC5V(); }} 适配器模式的优缺点优点 能提高类的透明性和复用，现有的类复用但不需要改变。 目标类和适配器类解耦，提高程序的扩展性。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。","link":"/2019/08/08/design-2019-08-设计模式（四）：适配器模式/"},{"title":"设计模式：分类","text":"设计模式的分类跟据其目的（模式是用来做什么的）一、创建型(Creational)创建型模式主要用于创建对象。 抽象工厂模式(Abstract Factory) 建造者模式(Builder) 工厂方法模式(Factory Method) 原型模式(Prototype) 单例模式(Singleton) 二、结构型(Structural)结构型模式主要用于处理类或对象的组合。 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 三、行为型模式行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。 职责链模式(Chain of Responsibility) 命令模式(Command) 解释器模式(Interpreter) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Visitor) 根据范围（模式主要是用于处理类之间关系还是处理对象之间的关系）可分为类模式和对象模式两种 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是属于静态的。 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。","link":"/2019/08/04/design-2019-08-设计模式：分类/"},{"title":"设计模式（二）：代理模式","text":"代理模式（Proxy Pattern）定义是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用代理模式主要有两个目的：一、保护目标对象，二、增强目标对象。 常见实现SpringAop 静态代理（static proxy）抽象的说，就是代理对象持有被代理对象的引用进行方法增强。举个例子：在深圳租房子，我们自己去找房很难直接联系上房东。一般会联系中介或者管理处（proxy），间接的租房。有的全权代理的房东坐等收钱，而中介可以在收租前后做各种不需要告诉老板的事，比如装修一番再涨个价赚取中间商差价。 动态代理（dynamic proxy）动态，指的是不直接引用被代理对象，并且可以代理不同的对象。Spring AOP面向切面编程的原理正是如此。举个例子，快递公司要帮人寄送快递，但他不需要知道那个人是谁。只要按流程填写快递单就行了。“快递单”在这里就是被代理对象。沿用这个例子展开分析。 1.JDK Proxy12345678910111213141516171819202122232425/** * Created by miaozc on 2019-8-2. * 快递公司-动态代理发送快递 */public class ExpressCompanyJDKProxy implements InvocationHandler { private Object target; public Object getInstance(Object object)throws Exception{ this.target = object; Class&lt;?&gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object object = method.invoke(this.target,args); send(); return object; } public void send(){ System.out.println(\"jdk动态代理-快递公司发出快递！\"); }} 测试代码：12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));jdkCustomer.send(); JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。JDK Proxy 生成对象的步骤如下： 拿到被代理对象的引用，反射获取它所有的接口。 JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。 动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。 编译新生成的 Java 代码: $Proxy***.class。 再重新加载到 JVM 中运行。 以上这个过程就叫字节码重组。JDK 中有一个规范，在 ClassPath 下只要是$开头的 class文件一般都是自动生成的。查看代替后对象方式如下： 12ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\"));byte [] bytes = ProxyGenerator.generateProxyClass(\"$Proxy0\",new Class[]{Person.class}); FileOutputStream os = new FileOutputStream(\"E://$Proxy0.class\"); 2. CGLib Proxy与JDK代理不同，CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现的动态代理。这样的做法弊端就是无法代理final关键字修饰的方法。.好处则更加明显，在频繁调用代理的情况下，省去了反射带来的开销。 代理实现： 12345678910111213141516171819202122232425public class ExpressCompanyCGLibProxy implements MethodInterceptor { public Object getInstance(Class&lt;?&gt; clazz,Class[] argumentTypes, Object[] arguments) throws Exception{ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); if(argumentTypes==null){ return enhancer.create(); }else{ return enhancer.create(argumentTypes, arguments); } } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { Object object = methodProxy.invokeSuper(o,objects); send(); return object; } public void send(){ System.out.println(\"cglib动态代理-快递公司发出快递！\"); }} 测试代码： 12345678910111213//构造方法所需参数Class[] argumentTypes = new Class[]{String.class};Object[] personArguments = new Object[]{\"王五\"};Object[] robotArguments = new Object[]{\"二哈\"};Customer cglibCustomer = (Customer) new ExpressCompanyCGLibProxy(). getInstance(Customer.class,argumentTypes,personArguments);Robot cglibRobot = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,argumentTypes,robotArguments);Robot cglibRobotCreate = (Robot) new ExpressCompanyCGLibProxy(). getInstance(Robot.class,null,null);cglibCustomer.send();cglibRobot.send();cglibRobotCreate.send(); 将 CGLib 代理后的 class 写入到磁盘： 1234//利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,\"E://cglib_proxy_class/\");ICustomer jdkCustomer = (ICustomer) new ExpressCompanyJDKProxy().getInstance(new Customer(\"李四\")); 我们会发现在 E://cglib_proxy_class 目录下多了三个 class 文件 ObjectName$$EnhancerByCGLIB$$3feeb52a.class CGLib生成的代理类，继承了被代理对象。重写了 被代理对象类的所有方法，并且生成代理的方法的增强逻辑以及增强逻辑所需要的方法。这直接导致了我们如果在拦截器里直接调用method.invoke()会死循环。所以我们切记在代理拦截器中应该使用methodProxy.invokeSuper(o,objects)。 ObjectName$$EnhancerByCGLIB$$3feeb52a$$FastClassByCGLIB$$6aad62f1.class 代理类的 FastClass。 Customer$$FastClassByCGLIB$$2669574a.class 被代理类的FastClass。 CGLib 动态代理执行代理方法效率之所以比 JDK的高是因为 Cglib 采用了 FastClass 机制，它的原理简单来说就是：为代理类和被代理类各生成一个 Class，这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高。FastClass 并不是跟代理类一块生成的，而是在第一次执行 MethodProxy.invoke()/invokeSuper() 时生成的并放在了缓存中。 CGLib 和 JDK 动态代理对比 JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。 JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。 Spring中的代理模式代理模式选择 当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理 当 Bean 没有实现接口时，Spring 选择 CGLib。 Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码： 1&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 静态代理和动态的本质区别 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。 代理模式的优缺点使用代理模式具有以下几个优点： 代理模式能将代理对象与真实被调用的目标对象分离。 一定程度上降低了系统的耦合度，扩展性好。 可以起到保护目标对象的作用。 可以对目标对象的功能增强。 当然，代理模式也是有缺点的： 代理模式会造成系统设计中类的数量增加。 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。 增加了系统的复杂度。","link":"/2019/08/04/design-2019-08-设计模式（二）：代理模式/"},{"title":"设计模式：七大原则","text":"软件架构设计的七大原则一、开闭原则开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调 的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开 闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统， 例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间， 规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。 二、依赖倒置原则依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模 块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖 抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的 可读性和可维护性，并能够降低修改程序所造成的风险。 三、单一职责原则单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更 的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的 逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现， 进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的 可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个 Class/Interface/Method 只负责一项职责。 四、接口隔离原则接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点： 1、一个类对一类的依赖应该建立在最小的接口之上。 2、建立单一接口，不要建立庞大臃肿的接口。 3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。 接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解 是非常重要的。 五、迪米特法则迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又 叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪 米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 六、里氏替换原则里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对 象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对 象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下： 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类 方法的输入参数更宽松。 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即 方法的输出/返回值）要比父类更严格或相等。 使用里氏替换原则有以下优点： 约束继承泛滥，开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩 展性。降低需求变更时引入的风险。 里氏替换原则只存在父类与子类之间，约束继承泛滥。 七、合成复用原则合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组 合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。 设计原则总结学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都 遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的 场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。","link":"/2019/08/04/design-2019-08-设计模式：七大原则/"},{"title":"渐入Spring-IOC","text":"渐入Spring-IOC一、IOC Spring核心容器类图 BeanFactory Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下： 其中 BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，它实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表化的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。最基本的 IOC 容器接口 BeanFactory，来看一下它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.springframework.beans.factory;import org.springframework.beans.BeansException;import org.springframework.core.ResolvableType;import org.springframework.lang.Nullable;public interface BeanFactory { //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，如果需要得到工厂本身，需要转义 String FACTORY_BEAN_PREFIX = \"&amp;\"; //根据bean的名字，获取在IOC容器中得到bean实例 Object getBean(String name) throws BeansException; //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。 &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; //提供对bean的检索，看看是否在IOC容器有这个名字的bean boolean containsBean(String name); //根据bean名字得到bean实例，并同时判断这个bean是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; //得到bean实例的Class类型 @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来 String[] getAliases(String name);} 在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 Bean 是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的实现 。 比如 GenericApplicationContext ， ClasspathXmlApplicationContext 等 。ApplicationContext 是 Spring 提供的一个高级的 IOC 容器，它除了能够提供 IOC 容器的基本功能外，还为用户提供了以下的附加服务。 从 ApplicationContext 接口的实现，我们看出其特点： 1、支持信息源，可以实现国际化。（实现 MessageSource 接口）2、访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到)3、支持应用事件。(实现 ApplicationEventPublisher 接口) BeanDefinition SpringIOC 容器管理了我们定义的各种 Bean 对象及其相互的关系，Bean 对象在 Spring 实现中是以 BeanDefinition 来描述的，其继承体系如下： BeanDefinitionReader Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，最后看看 Spring 中 BeanDefinitionReader的类结构图： 延伸–寻找Web IOC入口 以DispatcherServlet为例, DispatcherServlet继承&gt;HttpServletBean执行init()方法如下: 1234567891011121314151617181920212223242526272829303132public final void init() throws ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); } // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { //定位资源 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); //加载配置信息 ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); } throw ex; } } // Let subclasses do whatever initialization they like. initServletBean(); if (logger.isDebugEnabled()) { logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); } } 在 init()方法中，真正完成初始化容器动作的逻辑其实在 initServletBean()方法中，这是个钩子方法, 我们继续跟进initServletBean()中的代码在 FrameworkServlet 类中： 12345678910111213141516171819202122232425262728@Override protected final void initServletBean() throws ServletException { getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) { this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); } long startTime = System.currentTimeMillis(); try { this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } catch (RuntimeException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); } } 继续跟进 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162protected WebApplicationContext initWebApplicationContext() { //先从ServletContext中获得父容器WebAppliationContext WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); //声明子容器 WebApplicationContext wac = null; //建立父、子容器之间的关联关系 if (this.webApplicationContext != null) { // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } //这个方法里面调用了AbatractApplication的refresh()方法 //模板方法，规定IOC初始化基本流程 configureAndRefreshWebApplicationContext(cwac); } } } //先去ServletContext中查找Web容器的引用是否存在，并创建好默认的空IOC容器 if (wac == null) { // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } //给上一步创建好的IOC容器赋值 if (wac == null) { // No context instance is defined for this servlet -&gt; create a local one wac = createWebApplicationContext(rootContext); } //触发onRefresh方法 if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. onRefresh(wac); } if (this.publishContext) { // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() + \"' as ServletContext attribute with name [\" + attrName + \"]\"); } } return wac; } 在 configAndRefreshWebApplicationContext()方法中，调用 refresh()方法，这个是真正启动 IOC 容器的入口，后面会详细介绍。IOC 容器初始化以后，最后调用了DispatcherServlet 的 onRefresh()方法，onRefresh()是为DispatcherServlet提供的钩子方法,在 onRefresh()方法中又是直接调用 initStrategies()方法初始化 SpringMVC 的九大组件： 123456789101112131415161718192021222324252627public class DispatcherServlet extends FrameworkServlet { //DispatcherServlet protected void onRefresh(ApplicationContext context) { initStrategies(context); } //初始化策略 protected void initStrategies(ApplicationContext context) { //多文件上传的组件 initMultipartResolver(context); //初始化本地语言环境 initLocaleResolver(context); //初始化模板处理器 initThemeResolver(context); //handlerMapping initHandlerMappings(context); //初始化参数适配器 initHandlerAdapters(context); //初始化异常拦截器 initHandlerExceptionResolvers(context); //初始化视图预处理器 initRequestToViewNameTranslator(context); //初始化视图转换器 initViewResolvers(context); // initFlashMapManager(context); }} 基于XML的IOC容器初始化原理IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、加载和注册这三个基本的过程。我们以ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示： ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring应用提供了一个共享的 Bean 定义环境。 寻找入口 我们用的比较多的 ClassPathXmlApplicationContext，通过 main()方法启动: 1ApplicationContext app = new ClassPathXmlApplicationContext(\"application.xml\"); 先看其构造函数的调用： 123public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[]{configLocation}, true, (ApplicationContext)null);} 其实际调用的构造函数为： 1234567public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); this.setConfigLocations(configLocations); if(refresh) { this.refresh(); }} 还有像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、XmlWebApplicationContext等都继承自父容器AbstractApplicationContext主要用到了装饰器模式和策略模式，最终都是调用 refresh()方法。 获得配置路径 通过分析ClassPathXmlApplicationContext的源代码可以知道, 在创建ClassPathXmlApplicationContext容器时, 构造方法做了两项重要工作:首先, 调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器. 然后, 再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置 Bean 配置信息的定位路径. 通过追踪ClassPathXmlApplicationContext的继承体系, 发现其超类AbstractApplicationContext中初始化IOC容器所得的主要源码如下: 1234567891011121314151617181920212223public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { //静态初始化块，在整个容器创建过程中只执行一次 static { //为了避免应用程序在 Weblogic8.1 关闭时出现类加载异常加载问题，加载 IOC 容 //器关闭事件(ContextClosedEvent)类 ContextClosedEvent.class.getName(); } public AbstractApplicationContext() { this.resourcePatternResolver = getResourcePatternResolver(); } public AbstractApplicationContext(@Nullable ApplicationContext parent) { this(); setParent(parent); } //获取一个 Spring Source 的加载器用于读入 Spring Bean 配置信息 protected ResourcePatternResolver getResourcePatternResolver() { //AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器 //Spring 资源加载器，其 getResource(String location)方法用于载入资源 return new PathMatchingResourcePatternResolver(this); }...} AbstractApplicationContext 的默认构造方法中有调用 PathMatchingResourcePatternResolver 的构造方法创建 Spring 资源加载器： 12345public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) { Assert.notNull(resourceLoader, \"ResourceLoader must not be null\"); //设置 Spring 的资源加载器 this.resourceLoader = resourceLoader;} 在设置容器的资源加载器之后，接下来 ClassPathXmlApplicationContext 执行setConfigLocations()方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean配置信息的定位，该方法的源码如下： 12345678910111213141516171819202122232425//处理单个资源文件路径为一个字符串的情况public void setConfigLocation(String location) { //String CONFIG_LOCATION_DELIMITERS = \",; /t/n\"; //即多个资源文件路径之间用” ,; \\t\\n”分隔，解析成数组形式 setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));} /** * Set the config locations for this application context. * &lt;p&gt;If not set, the implementation may use a default as appropriate. *///解析Bean定义资源文件的路径，处理多个资源文件字符串数组public void setConfigLocations(@Nullable String... locations) { if (locations != null) { Assert.noNullElements(locations, \"Config locations must not be null\"); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) { // resolvePath为同一个类中将字符串解析为路径的方法 this.configLocations[i] = resolvePath(locations[i]).trim(); } } else { this.configLocations = null; }} 通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 配置信息，也可以使用字符串数组，即下面两种方式都是可以的： 1234//法1ClassPathResource res = new ClassPathResource(\"a.xml,b.xml\");//法2ClassPathResource res =new ClassPathResource(new String[]{\"a.xml\",\"b.xml\"}); 开始启动 SpringIOC 容器对 Bean 配置资源的载入是从refresh()函数开始的，refresh()是一个模板方法，规定了IOC容器的启动流程 ， 有些逻辑要交给其子类去实 现 。它对 Bean配置资源进行载入ClassPathXmlApplicationContext 通过调用其父类AbstractApplicationContext 的 refresh()函数启动整个 IOC 容器对 Bean 定义的载入过程，现在我们来详细看看 refresh()中的逻辑处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. //1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //3、为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. //4、为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //5、调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //6、为BeanFactory注册BeanPost事件处理器. //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //7、初始化信息源，和国际化相关. initMessageSource(); // Initialize event multicaster for this context. //8、初始化容器事件传播器. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //9、调用子类的某些特殊Bean初始化方法 onRefresh(); // Check for listener beans and register them. //10、为事件传播器注册事件监听器. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //11、初始化所有剩余的单例Bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. //13、销毁已创建的Bean destroyBeans(); // Reset 'active' flag. //14、取消refresh操作，重置容器的同步标识。 cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... //15、重设公共缓存 resetCommonCaches(); } } } refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 配置信息从其子类容器的refreshBeanFactory()方法启动, 所以整个refresh()中 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();这句以后代码都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。 refresh()方法的主要作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。它类似于对 IOC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 配置资源进行载入。 创建容器 obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入 Bean 配置信息的过程，代码如下： 12345678910protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { //这里使用了委派设计模式，父类定义了抽象的 refreshBeanFactory()方法，具体实现调用子类容器的 refreshBeanFactory()方 法 refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) { logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); } return beanFactory;} AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是其子类 AbstractRefreshableApplicationContext 实现的 refreshBeanFactory()方法，方法的源码如下： 12345678910111213141516171819202122protected final void refreshBeanFactory() throws BeansException { //如果已经有容器，销毁容器中的bean，关闭容器 if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { //创建IOC容器 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); //对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等 customizeBeanFactory(beanFactory); //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } 在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载 bean 定义。 载入配置路径 AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext的主要源码如下：loadBeanDefinitions()方法同样是抽象方法, 是由其子类实现的, 也即在AbstractXmlApplicationContext 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {... //实现父类抽象的载入 Bean 定义方法 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { //创建 XmlBeanDefinitionReader，即创建 Bean 读取器，并通过回调设置到容器中去，容器使用该读取器读取 Bean 配置资源 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); //为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的 //祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); //为 Bean 读取器设置 SAX xml 解析器 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); //当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制 initBeanDefinitionReader(beanDefinitionReader); //Bean 读取器真正实现加载的方法 loadBeanDefinitions(beanDefinitionReader); } protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) { reader.setValidating(this.validating); } //Xml Bean 读取器加载 Bean 配置资源 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { //获取 Bean 配置资源的定位 Resource[] configResources = getConfigResources(); if (configResources != null) { //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源 reader.loadBeanDefinitions(configResources); } // 如果子类中获取的 Bean 配置资源定位为空，则获取 ClassPathXmlApplicationContext // 构造方法中 setConfigLocations 方法设置的资源 String[] configLocations = getConfigLocations(); if (configLocations != null) { //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源 reader.loadBeanDefinitions(configLocations); } } //这里又使用了一个委托模式，调用子类的获取 Bean 配置资源定位的方法 //该方法在 ClassPathXmlApplicationContext 中进行实现，对于我们 //举例分析源码的 ClassPathXmlApplicationContext 没有使用该方法 @Nullable protected Resource[] getConfigResources() { return null; }} 以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。由于我们使用 ClassPathXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。 分配路径处理策略 在 XmlBeanDefinitionReader 的抽象父类 AbstractBeanDefinitionReader 中定义了载入过程。AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法@Overridepublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException { return loadBeanDefinitions(location, null);}public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException { //获取在IoC容器初始化过程中设置的资源加载器 ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException( \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\"); } if (resourceLoader instanceof ResourcePatternResolver) { // Resource pattern matching available. try { //将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源 //加载多个指定位置的Bean定义资源文件 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resources); if (actualResources != null) { for (Resource resource : resources) { actualResources.add(resource); } } if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\"); } return loadCount; } catch (IOException ex) { throw new BeanDefinitionStoreException( \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex); } } else { // Can only load single resources by absolute URL. //将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源 //加载单个指定位置的Bean定义资源文件 Resource resource = resourceLoader.getResource(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resource); if (actualResources != null) { actualResources.add(resource); } if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\"); } return loadCount; }} //重载方法，调用loadBeanDefinitions(String);@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \"Location array must not be null\"); int counter = 0; for (String location : locations) { counter += loadBeanDefinitions(location); } return counter;} AbstractRefreshableConfigApplicationContext 的 loadBeanDefinitions(Resource...resources) 方法实际上是调用 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法。从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码分析可以看出该方法就做了两件事：首先，调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在loadBeanDefinitions()方法中调用了 AbstractApplicationContext 的 getResources()方法，跟进去之后发现getResources()方法其实定义在 ResourcePatternResolver 中，此时，我们有必要来看一下ResourcePatternResolver 的全类图： 从上面可以看到 ResourceLoader 与 ApplicationContext 的继承关系，可以看出其实际调用的是DefaultResourceLoader中的getSource() 方法定位 Resource ，因为ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了ClassPathXmlApplicationContext 中来。 解析配置文件路径 XmlBeanDefinitionReader通过配置文件ClassPathXmlApplicationContext的父类DefaultResourceLoader的 getResource()方法获取要加载的资源，其源码如下 123456789101112131415161718192021222324252627282930313233//获取Resource的具体实现方法 @Override public Resource getResource(String location) { Assert.notNull(location, \"Location must not be null\"); for (ProtocolResolver protocolResolver : this.protocolResolvers) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } //如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象 if (location.startsWith(\"/\")) { return getResourceByPath(location); } else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // Try to parse the location as a URL... // 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象 URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&gt; resolve as resource path. //如果既不是classpath标识，又不是URL标识的Resource定位，则调用 //容器本身的getResourceByPath方法获取Resource return getResourceByPath(location); } } } DefaultResourceLoader 提供了 getResourceByPath()方法的实现，就是为了处理既不是 classpath标识，又不是 URL 标识的 Resource 定位这种情况。 123protected Resource getResourceByPath(String path) {return new ClassPathContextResource(path, getClassLoader());} 在 ClassPathResource 中完成了对整个路径的解析。这样，就可以从类路径上对 IOC 配置文件进行加载，当然我们可以按照这个逻辑从任何地方加载，在 Spring 中我们看到它提供的各种资源抽象，比如ClassPathResource、URLResource、FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分。例如 FileSystemXmlApplication 容器就重写了getResourceByPath()方法： 12345678@Overrideprotected Resource getResourceByPath(String path) { if (path.startsWith(\"/\")) { path = path.substring(1); } //这里使用文件系统资源对象来定义 bean 文件 return new FileSystemResource(path);} 通过子类的覆盖，巧妙地完成了将类路径变为文件路径的转换。 开始读取配置内容 继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文件的资源定义以后的载入过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//XmlBeanDefinitionReader加载资源的入口方法@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { //将读入的XML资源进行特殊编码处理 return loadBeanDefinitions(new EncodedResource(resource));}//这里是载入XML形式Bean定义资源文件方法public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) { logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); } Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); } try { //将资源文件转为InputStream的IO流 InputStream inputStream = encodedResource.getResource().getInputStream(); try { //从InputStream中得到XML的解析源 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //这里是具体的读取过程 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { //关闭从Resource中得到的IO流 inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }} 载入 Bean 配置信息的最后一步是将 Bean 配置信息转换为 Document 对象，该过程由documentLoader()方法实现。 准备文档对象 DocumentLoader 将 Bean 配置资源转换成 Document 对象的源码如下： 123456789101112131415161718public class DefaultDocumentLoader implements DocumentLoader { ... //使用标准的JAXP将载入的Bean定义资源转换成document对象 @Override public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception { //创建文件解析器工厂 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) { logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\"); } //创建文档解析器 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); //解析Spring的Bean定义资源 return builder.parse(inputSource); }} 上面的解析过程是调用 JavaEE 标准的 JAXP 标准进行处理。至此 Spring IOC 容器根据定位的 Bean 配置信息，将其加载读入并转换成为 Document 对象过程完成。接下来我们要继续分析 Spring IOC 容器将载入的 Bean 配置信息转换为 Document 对象之后，是如何将其解析为Spring IOC 管理的 Bean 对象并将其注册到容器中的。 分配解析策略 XmlBeanDefinitionReader 类中的 doLoadBeanDefinition()方法是从特定 XML 文件中实际载入Bean 配置资源的方法，该方法在载入 Bean 配置资源之后将其转换为 Document 对象，接下来调用registerBeanDefinitions() 启 动 Spring IOC 容 器 对 Bean定义的解析过程，registerBeanDefinitions()方法源码如下： 123456789101112//按照 Spring 的 Bean 语义要求将 Bean 配置资源解析并转换为容器内部数据结构public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { //得到 BeanDefinitionDocumentReader 来对 xml 格式的 BeanDefinition 解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获得容器中注册的 Bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader 只是个接口, //具体的解析实现过程有实现类 DefaultBeanDefinitionDocumentReader 完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //统计解析的 Bean 数量 return getRegistry().getBeanDefinitionCount() - countBefore;} Bean 配置资源的载入解析分为以下两个过程： 首先，通过调用 XML 解析器将 Bean 配置信息转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程. 其次，在完成通用的 XML 解析之后，按照 Spring Bean 的定义规则对 Document 对象进行解析，其解析过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的 将配置载入内存 BeanDefinitionDocumentReader 接 口 通 过 registerBeanDefinitions() 方 法 调 用 其 实现类DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248 //根据Spring DTD对Bean的定义规则解析Bean定义Document对象 @Override public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { //获得XML描述符 this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); //获得Document的根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root); }protected void doRegisterBeanDefinitions(Element root) { //具体的解析过程由BeanDefinitionParserDelegate实现， //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性 preProcessXml(root); //从Document的根元素开始进行Bean定义的Document对象 parseBeanDefinitions(root, this.delegate); //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性 postProcessXml(root); this.delegate = parent; } //创建BeanDefinitionParserDelegate，用于完成真正的解析过程 protected BeanDefinitionParserDelegate createDelegate( XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) { BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); //BeanDefinitionParserDelegate初始化Document根元素 delegate.initDefaults(root, parentDelegate); return delegate; } //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { //Bean定义的Document对象使用了Spring默认的XML命名空间 if (delegate.isDefaultNamespace(root)) { //获取Bean定义的Document对象根元素的所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //获得Document节点是XML元素节点 if (node instanceof Element) { Element ele = (Element) node; //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间 if (delegate.isDefaultNamespace(ele)) { //使用Spring的Bean规则解析元素节点 parseDefaultElement(ele, delegate); } else { //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点 delegate.parseCustomElement(ele); } } } } else { //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的 //解析规则解析Document根节点 delegate.parseCustomElement(root); } } //使用Spring的Bean规则解析Document元素节点 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { //如果元素节点是&lt;Import&gt;导入元素，进行导入解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } //如果元素节点是&lt;Alias&gt;别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } //元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素， //按照Spring的Bean规则解析元素 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } /** * Parse an \"import\" element and load the bean definitions * from the given resource into the bean factory. */ //解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中 protected void importBeanDefinitionResource(Element ele) { //获取给定的导入元素的location属性 String location = ele.getAttribute(RESOURCE_ATTRIBUTE); //如果导入元素的location属性值为空，则没有导入任何资源，直接返回 if (!StringUtils.hasText(location)) { getReaderContext().error(\"Resource location must not be empty\", ele); return; } // Resolve system properties: e.g. \"${user.dir}\" //使用系统变量值解析location属性值 location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location); Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4); // Discover whether the location is an absolute or relative URI //标识给定的导入元素的location是否是绝对路径 boolean absoluteLocation = false; try { absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); } catch (URISyntaxException ex) { // cannot convert to an URI, considering the location relative // unless it is the well-known Spring prefix \"classpath*:\" //给定的导入元素的location不是绝对路径 } // Absolute or relative? //给定的导入元素的location是绝对路径 if (absoluteLocation) { try { //使用资源读入器加载给定路径的Bean定义资源 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isDebugEnabled()) { logger.debug(\"Imported \" + importCount + \" bean definitions from URL location [\" + location + \"]\"); } } catch (BeanDefinitionStoreException ex) { getReaderContext().error( \"Failed to import bean definitions from URL location [\" + location + \"]\", ele, ex); } } else { // No URL -&gt; considering resource location as relative to the current file. //给定的导入元素的location是相对路径 try { int importCount; //将给定导入元素的location封装为相对路径资源 Resource relativeResource = getReaderContext().getResource().createRelative(location); //封装的相对路径资源存在 if (relativeResource.exists()) { //使用资源读入器加载Bean定义资源 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); } //封装的相对路径资源不存在 else { //获取Spring IOC容器资源读入器的基本路径 String baseLocation = getReaderContext().getResource().getURL().toString(); //根据Spring IOC容器资源读入器的基本路径加载给定导入路径的资源 importCount = getReaderContext().getReader().loadBeanDefinitions( StringUtils.applyRelativePath(baseLocation, location), actualResources); } if (logger.isDebugEnabled()) { logger.debug(\"Imported \" + importCount + \" bean definitions from relative location [\" + location + \"]\"); } } catch (IOException ex) { getReaderContext().error(\"Failed to resolve current resource location\", ele, ex); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to import bean definitions from relative location [\" + location + \"]\", ele, ex); } } Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]); //在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); } /** * Process the given alias element, registering the alias with the registry. */ //解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名 protected void processAliasRegistration(Element ele) { //获取&lt;Alias&gt;别名元素中name的属性值 String name = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Alias&gt;别名元素中alias的属性值 String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; //&lt;alias&gt;别名元素的name属性值为空 if (!StringUtils.hasText(name)) { getReaderContext().error(\"Name must not be empty\", ele); valid = false; } //&lt;alias&gt;别名元素的alias属性值为空 if (!StringUtils.hasText(alias)) { getReaderContext().error(\"Alias must not be empty\", ele); valid = false; } if (valid) { try { //向容器的资源读入器注册别名 getReaderContext().getRegistry().registerAlias(name, alias); } catch (Exception ex) { getReaderContext().error(\"Failed to register alias '\" + alias + \"' for bean with name '\" + name + \"'\", ele, ex); } //在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); } } /** * Process the given bean element, parsing the bean definition * and registering it with the registry. */ //解析Bean定义资源Document对象的普通元素 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类 //对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现 // BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. //向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. //在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 通过上述 Spring IOC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在Spring 配置文件中可以使用&lt;import&gt;元素来导入 IOC 容器所需要的其他资源，Spring IOC 容器在解析时会首先将指定导入的资源加载进容器中。使用&lt;ailas&gt;别名时，Spring IOC 容器首先将别名元素所定义的别名注册到容器中。对于既不是&lt;import&gt;元素，又不是&lt;alias&gt;元素的元素，即 Spring 配置文件中普通的&lt;bean&gt;元素的解析由BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement()方法来实现。 载入&lt;bean&gt;元素 Bean 配置信息中的&lt;import&gt;和&lt;alias&gt;元素解析在 DefaultBeanDefinitionDocumentReader 中已经完成，对 Bean 配置信息中使用最多的&lt;bean&gt;元素交由 BeanDefinitionParserDelegate 来解析，其解析实现的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//解析&lt;Bean&gt;元素的入口@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);} //解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name和别名属性@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { //获取&lt;Bean&gt;元素中的id属性值 String id = ele.getAttribute(ID_ATTRIBUTE); //获取&lt;Bean&gt;元素中的name属性值 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Bean&gt;元素中的alias属性值 List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); //将&lt;Bean&gt;元素中的所有name属性值存放到别名中 if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; //如果&lt;Bean&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); } } //检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt; //元素中是否包含子&lt;Bean&gt;元素 if (containingBean == null) { //检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复 checkNameUniqueness(beanName, aliases, ele); } //详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子元素 //&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子元素 //&lt;Bean&gt;元素，为解析的Bean使用别名向IOC容器注册 beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀 String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } //当解析出错时，返回null return null;}//详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析//由于上面的方法中已经对Bean的id、name和别名等属性进行了处理//该方法中主要处理除这三个以外的其他属性数据@Nullablepublic AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { //记录解析的&lt;Bean&gt; this.parseState.push(new BeanEntry(beanName)); //这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成 String className = null; //如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值 if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { //根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition //为载入Bean定义信息做准备 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //对&lt;Bean&gt;元素的meta(元信息)属性解析 parseMetaElements(ele, bd); //对&lt;Bean&gt;元素的lookup-method属性解析 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //对&lt;Bean&gt;元素的replaced-method属性解析 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析&lt;Bean&gt;元素的构造方法设置 parseConstructorArgElements(ele, bd); //解析&lt;Bean&gt;元素的&lt;property&gt;设置 parsePropertyElements(ele, bd); //解析&lt;Bean&gt;元素的qualifier属性 parseQualifierElements(ele, bd); //为当前解析的Bean设置所需的资源和依赖对象 bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } //解析&lt;Bean&gt;元素出错时，返回null return null;} 只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring配置文件中&lt;Bean&gt;元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。注意：在解析&lt;Bean&gt;元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类BeanDefinition，将&lt;Bean&gt;元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。上面方法中一些对一些配置如元信息(meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不多，我们在使用 Spring 的&lt;Bean&gt;元素时，配置最多的是&lt;property&gt;属性，因此我们下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。 载入&lt;property&gt;元素 BeanDefinitionParserDelegate 在解析&lt;Bean&gt;调用 parsePropertyElements()方法解析&lt;Bean&gt;元素中的&lt;property&gt;属性子元素，解析源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素 public void parsePropertyElements(Element beanEle, BeanDefinition bd) { //获取&lt;Bean&gt;元素中所有的子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析 if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { parsePropertyElement((Element) node, bd); } } }//解析&lt;property&gt;元素 public void parsePropertyElement(Element ele, BeanDefinition bd) { //获取&lt;property&gt;元素的名字 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(\"Tag 'property' must have a 'name' attribute\", ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。 //即如果在同一个Bean中配置同名的property，则只有第一个起作用 if (bd.getPropertyValues().contains(propertyName)) { error(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele); return; } //解析获取property的值 Object val = parsePropertyValue(ele, bd, propertyName); //根据property的名字和值创建property实例 PropertyValue pv = new PropertyValue(propertyName, val); //解析&lt;property&gt;元素中的属性 parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); } }//解析获取property值 @Nullable public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) { String elementName = (propertyName != null) ? \"&lt;property&gt; element for property '\" + propertyName + \"'\" : \"&lt;constructor-arg&gt; element\"; // Should only have one child element: ref, value, list, etc. //获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list,etc等 NodeList nl = ele.getChildNodes(); Element subElement = null; for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); //子元素不是description和meta属性 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !nodeNameEquals(node, META_ELEMENT)) { // Child element is what we're looking for. if (subElement != null) { error(elementName + \" must not contain more than one sub-element\", ele); } else { //当前&lt;property&gt;元素包含有子元素 subElement = (Element) node; } } } //判断property的属性值是ref还是value，不允许既是ref又是value boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); if ((hasRefAttribute &amp;&amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) { error(elementName + \" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele); } //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference //这个对象封装了ref信息 if (hasRefAttribute) { String refName = ele.getAttribute(REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(elementName + \" contains empty 'ref' attribute\", ele); } //一个指向运行时所依赖对象的引用 RuntimeBeanReference ref = new RuntimeBeanReference(refName); //设置这个ref的数据对象是被当前的property对象所引用 ref.setSource(extractSource(ele)); return ref; } //如果属性是value，创建一个value的数据对象TypedStringValue //这个对象封装了value信息 else if (hasValueAttribute) { //一个持有String类型值的对象 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); //设置这个value数据对象是被当前的property对象所引用 valueHolder.setSource(extractSource(ele)); return valueHolder; } //如果当前&lt;property&gt;元素还有子元素 else if (subElement != null) { //解析&lt;property&gt;的子元素 return parsePropertySubElement(subElement, bd); } else { // Neither child element nor \"ref\" or \"value\" attribute found. //propery属性中既不是ref，也不是value属性，解析出错返回null error(elementName + \" must specify a ref or value\", ele); return null; } } @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) { return parsePropertySubElement(ele, bd, null); } 通过对上述源码的分析，我们可以了解在 Spring 配置文件中，&lt;Bean&gt;元素中&lt;property&gt;元素的相关配置是如何处理的： ref 被封装为指向依赖对象一个引用。 value 配置都会封装成一个字符串类型的对象。 ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来。在方法的最后对于&lt;property&gt;元素的子元素通过 parsePropertySubElement ()方法解析，我们继续分析该方法的源码，了解其解析过程。 载入&lt;property&gt;子元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//解析&lt;property&gt;元素中ref,value或者集合等子元素 @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) { //如果&lt;property&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析内嵌元素 if (!isDefaultNamespace(ele)) { return parseNestedCustomElement(ele, bd); } //如果子元素是bean，则使用解析&lt;Bean&gt;元素的方法解析 else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent else if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. //获取&lt;property&gt;元素中parent属性值，引用父级容器中的Bean refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; if (!StringUtils.hasLength(refName)) { error(\"'bean' or 'parent' is required for &lt;ref&gt; element\", ele); return null; } } if (!StringUtils.hasText(refName)) { error(\"&lt;ref&gt; element contains empty target attribute\", ele); return null; } //创建ref类型数据，指向被引用的对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); //设置引用类型值是被当前子元素所引用 ref.setSource(extractSource(ele)); return ref; } //如果子元素是&lt;idref&gt;，使用解析ref元素的方法解析 else if (nodeNameEquals(ele, IDREF_ELEMENT)) { return parseIdRefElement(ele); } //如果子元素是&lt;value&gt;，使用解析value元素的方法解析 else if (nodeNameEquals(ele, VALUE_ELEMENT)) { return parseValueElement(ele, defaultValueType); } //如果子元素是null，为&lt;property&gt;设置一个封装null值的字符串数据 else if (nodeNameEquals(ele, NULL_ELEMENT)) { // It's a distinguished null value. Let's wrap it in a TypedStringValue // object in order to preserve the source location. TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; } //如果子元素是&lt;array&gt;，使用解析array集合子元素的方法解析 else if (nodeNameEquals(ele, ARRAY_ELEMENT)) { return parseArrayElement(ele, bd); } //如果子元素是&lt;list&gt;，使用解析list集合子元素的方法解析 else if (nodeNameEquals(ele, LIST_ELEMENT)) { return parseListElement(ele, bd); } //如果子元素是&lt;set&gt;，使用解析set集合子元素的方法解析 else if (nodeNameEquals(ele, SET_ELEMENT)) { return parseSetElement(ele, bd); } //如果子元素是&lt;map&gt;，使用解析map集合子元素的方法解析 else if (nodeNameEquals(ele, MAP_ELEMENT)) { return parseMapElement(ele, bd); } //如果子元素是&lt;props&gt;，使用解析props集合子元素的方法解析 else if (nodeNameEquals(ele, PROPS_ELEMENT)) { return parsePropsElement(ele); } //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null else { error(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele); return null; } } 通过上述源码分析，我们明白了在 Spring 配置文件中，对&lt;property&gt;元素中配置的 array、list、set、map、prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对&lt;list&gt;集合元素的解析方法进行源码分析，了解其实现过程。 载入&lt;list&gt;子元素 在 BeanDefinitionParserDelegate 类中的 parseListElement()方法就是具体实现解析&lt;property&gt;元素中的&lt;list&gt;集合子元素，源码如下： 1234567891011121314151617181920212223242526272829 //解析&lt;list&gt;集合子元素 public List&lt;Object&gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) { //获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); //获取&lt;list&gt;集合元素中的所有子节点 NodeList nl = collectionEle.getChildNodes(); //Spring中将List封装为ManagedList ManagedList&lt;Object&gt; target = new ManagedList&lt;&gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); //设置集合目标数据类型 target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); //具体的&lt;list&gt;元素解析 parseCollectionElements(nl, target, bd, defaultElementType); return target; }//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析 protected void parseCollectionElements( NodeList elementNodes, Collection&lt;Object&gt; target, @Nullable BeanDefinition bd, String defaultElementType) { //遍历集合所有节点 for (int i = 0; i &lt; elementNodes.getLength(); i++) { Node node = elementNodes.item(i); //节点不是description节点 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) { //将解析的元素加入集合中，递归调用下一个子元素 target.add(parsePropertySubElement((Element) node, bd, defaultElementType)); } } } 经过对 Spring Bean 配置信息转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将 XML形式定义的 Bean 配置信息转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是 Bean 配置信息中配置的 POJO 对象在 Spring IOC 容器中的映射，我们可以通过 AbstractBeanDefinition 为入口，看到了 IOC 容器进行索引、查询和操作。通过 Spring IOC 容器对 Bean 配置资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中BeanDefinition 存储的只是一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IOC 容器的初始化过程 分配注册策略 让我们继续跟踪程序的执行顺序，接下来我们来分析efaultBeanDefinitionDocumentReader 对Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement()方法中完成对Document对象的解析后得到封装BeanDefinition的BeanDefinitionHold对象 ，然后调用BeanDefinitionReaderUtils 的 registerBeanDefinition() 方法向IOC容器注册解析的Bean ，BeanDefinitionReaderUtils 的注册的源码如下： 12345678910111213141516//将解析的 BeanDefinitionHold 注册到容器中public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)throws BeanDefinitionStoreException { //获取解析的 BeanDefinition 的名称 String beanName = definitionHolder.getBeanName(); //向 IOC 容器注册 BeanDefinition registry.registerBeanDefinition(beanName,definitionHolder.getBeanDefinition()); //如果解析的 BeanDefinition 有别名，向容器为其注册别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { registry.registerAlias(beanName, alias); } }} 当调用 BeanDefinitionReaderUtils 向 IOC 容器注册解析的 BeanDefinition 时，真正完成注册功能的是 DefaultListableBeanFactory。 向容器注册 DefaultListableBeanFactory 中使用一个 HashMap 的集合对象存放 IOC 容器中注册解析的BeanDefinition，向 IOC 容器注册的主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//存储注册信息的BeanDefinitionprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);//向IOC容器注册解析的BeanDefiniton@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); //校验解析的BeanDefiniton if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Validation of bean definition failed\", ex); } } BeanDefinition oldBeanDefinition; oldBeanDefinition = this.beanDefinitionMap.get(beanName); if (oldBeanDefinition != null) { if (!isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName + \"': There is already [\" + oldBeanDefinition + \"] bound.\"); } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (this.logger.isWarnEnabled()) { this.logger.warn(\"Overriding user-defined bean definition for bean '\" + beanName + \"' with a framework-generated bean definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } else if (!beanDefinition.equals(oldBeanDefinition)) { if (this.logger.isInfoEnabled()) { this.logger.info(\"Overriding bean definition for bean '\" + beanName + \"' with a different definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } else { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Overriding bean definition for bean '\" + beanName + \"' with an equivalent definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); } } this.beanDefinitionMap.put(beanName, beanDefinition); } else { if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) //注册的过程中需要线程同步，以保证数据的一致性 synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); } this.frozenBeanDefinitionNames = null; } //检查是否有同名的BeanDefinition已经在IOC容器中注册 if (oldBeanDefinition != null || containsSingleton(beanName)) { //重置所有已经注册过的BeanDefinition的缓存 resetBeanDefinition(beanName); }} 至此，Bean 配置信息中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正完成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护。这些的注册的 Bean 定义信息是 IOC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。 基于Annotation的IOC初始化原理 Spring IOC 容器对于类级别的注解和类内部的注解分以下两种处理策略：1)、类级别的注解：如@Component、@Repository、@Controller、@Service 以及 JavaEE6 的@ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规则扫描读取注解 Bean 定义类，并将其注册到 Spring IOC 容器中。2)、类内部的注解：如@Autowire、@Value、@Resource 以及 EJB 和 WebService 相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过 Bean 后置注解处理器解析Bean 内部的注解。下面将根据这两种处理策略，分别分析 Spring 处理注解相关的源码。 定位 Bean 扫描路径 在Spring中管理注解Bean定义的容器有两个：AnnotationConfigApplicationContext和AnnotationConfigWebApplicationContex。这两个类是专门处理 Spring 注解方式配置的容器，直接依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext是AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。现在我们以 AnnotationConfigApplicationContext 为例看看它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry { //保存一个读取注解的Bean定义读取器，并将其设置到容器中 private final AnnotatedBeanDefinitionReader reader; //保存一个扫描指定类路径中注解Bean定义的扫描器，并将其设置到容器中 private final ClassPathBeanDefinitionScanner scanner; //默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其register() //方法注册配置类，并调用refresh()方法刷新容器，触发容器对注解Bean的载入、解析和注册过程 public AnnotationConfigApplicationContext() { this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) { super(beanFactory); this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } //最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的Bean自动注册到容器中 public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) { this(); register(annotatedClasses); refresh(); } //该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的Spring Bean，将其注册到容器中 public AnnotationConfigApplicationContext(String... basePackages) { this(); scan(basePackages); refresh(); } @Override public void setEnvironment(ConfigurableEnvironment environment) { super.setEnvironment(environment); this.reader.setEnvironment(environment); this.scanner.setEnvironment(environment); } //为容器的注解Bean读取器和注解Bean扫描器设置Bean名称产生器 public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) { this.reader.setBeanNameGenerator(beanNameGenerator); this.scanner.setBeanNameGenerator(beanNameGenerator); getBeanFactory().registerSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator); } //为容器的注解Bean读取器和注解Bean扫描器设置作用范围元信息解析器 public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) { this.reader.setScopeMetadataResolver(scopeMetadataResolver); this.scanner.setScopeMetadataResolver(scopeMetadataResolver); } //为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的 //refresh()方法刷新容器，触发容器对新注册的Bean的处理 public void register(Class&lt;?&gt;... annotatedClasses) { Assert.notEmpty(annotatedClasses, \"At least one annotated class must be specified\"); this.reader.register(annotatedClasses); } //扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用 //refresh()方法刷新容器 public void scan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); this.scanner.scan(basePackages); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, Object... constructorArguments) { registerBean(null, annotatedClass, constructorArguments); } public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; annotatedClass, Object... constructorArguments) { this.reader.doRegisterBean(annotatedClass, null, beanName, null, bd -&gt; { for (Object arg : constructorArguments) { bd.getConstructorArgumentValues().addGenericArgumentValue(arg); } }); } @Override public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; beanClass, @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers) { this.reader.doRegisterBean(beanClass, supplier, beanName, null, customizers); }} 通过上面的源码分析，我们可以看啊到 Spring 对注解的处理分为两种方式： 直接将注解 Bean 注册到容器中: 可以在初始化容器时注册；也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容器，使得容器对注册的注解 Bean 进行处理。 通过扫描指定的包及其子包下的所有类: 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。接下来，将会对两种处理方式详细分析其实现过程。 读取Annotation元数据 当创建注解处理容器时，如果传入的初始参数是具体的注解 Bean 定义类时，注解容器读取并注册。 1) 、AnnotationConfigApplicationContext 通过调用注解 Bean 定义读取器 AnnotatedBeanDefinitionReader 的 register()方法向容器注册指定的注解 Bean，注解 Bean 定义读取器向容器注册注解 Bean 的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class AnnotatedBeanDefinitionReader { //注册多个注解Bean定义类 public void register(Class&lt;?&gt;... annotatedClasses) { for (Class&lt;?&gt; annotatedClass : annotatedClasses) { registerBean(annotatedClass); } } //注册一个注解Bean定义类 public void registerBean(Class&lt;?&gt; annotatedClass) { doRegisterBean(annotatedClass, null, null, null); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier) { doRegisterBean(annotatedClass, instanceSupplier, null, null); } public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, String name, @Nullable Supplier&lt;T&gt; instanceSupplier) { doRegisterBean(annotatedClass, instanceSupplier, name, null); } //Bean定义读取器注册注解Bean定义的入口方法 @SuppressWarnings(\"unchecked\") public void registerBean(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers) { doRegisterBean(annotatedClass, null, null, qualifiers); } //Bean定义读取器向容器注册注解Bean定义类 @SuppressWarnings(\"unchecked\") public void registerBean(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers) { doRegisterBean(annotatedClass, null, name, qualifiers); } //Bean定义读取器向容器注册注解Bean定义类 &lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name, @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) { //根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构 AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) { return; } abd.setInstanceSupplier(instanceSupplier); //解析注解Bean定义的作用域，若@Scope(\"prototype\")，则Bean为原型类型； //若@Scope(\"singleton\")，则Bean为单态类型 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); //为注解Bean定义设置作用域 abd.setScope(scopeMetadata.getScopeName()); //为注解Bean定义生成Bean名称 String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry)); //处理注解Bean定义中的通用注解 AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); //如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。 //主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解 //Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称 if (qualifiers != null) { for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) { //如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选 if (Primary.class == qualifier) { abd.setPrimary(true); } //如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置， //则该Bean为预实例化 else if (Lazy.class == qualifier) { abd.setLazyInit(true); } //如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一 //个autowiring自动依赖注入装配限定符，该Bean在进autowiring //自动依赖注入装配时，根据名称装配限定符指定的Bean else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } for (BeanDefinitionCustomizer customizer : definitionCustomizers) { customizer.customize(abd); } //创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); //根据注解Bean定义类中配置的作用域，创建相应的代理对象 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); //向IOC容器注册注解Bean类定义对象 BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } private static Environment getOrCreateEnvironment(BeanDefinitionRegistry registry) { Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); if (registry instanceof EnvironmentCapable) { return ((EnvironmentCapable) registry).getEnvironment(); } return new StandardEnvironment(); }} 从上面的源码我们可以看出，注册注解 Bean 定义类的基本步骤：a、需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。 b、使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定义类中通用的注解。c、使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。d、通过 BeanDefinitionReaderUtils 向容器注册 Bean。 2)、AnnotationScopeMetadataResolver 解析作用域元数据 AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型，其源码如下： 12345678910111213141516171819202122232425262728//解析注解Bean定义类中的作用域元信息@Overridepublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) { ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) { AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; //从注解Bean定义类的属性中查找属性为”Scope”的值，即@Scope注解的值 //annDef.getMetadata().getAnnotationAttributes()方法将Bean //中所有的注解和注解的值存放在一个map集合中 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); //将获取到的@Scope注解的值设置到要返回的对象中 if (attributes != null) { metadata.setScopeName(attributes.getString(\"value\")); //获取@Scope注解中的proxyMode属性值，在创建代理对象时会用到 ScopedProxyMode proxyMode = attributes.getEnum(\"proxyMode\"); //如果@Scope的proxyMode属性为DEFAULT或者NO if (proxyMode == ScopedProxyMode.DEFAULT) { //设置proxyMode为NO proxyMode = this.defaultProxyMode; } //为返回的元数据设置proxyMode metadata.setScopedProxyMode(proxyMode); } } //返回解析的作用域元信息对象 return metadata;} 上述代码中的 annDef.getMetadata().getAnnotationAttributes()方法就是获取对象中指定类型的注解的值。 3)、AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解 AnnotationConfigUtils 类的 processCommonDefinitionAnnotations()在向容器注册 Bean 之前，首先对注解 Bean 定义类中的通用 Spring 注解进行处理，源码如下： 12345678910111213141516171819202122232425262728293031323334353637//处理Bean定义中通用注解 static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) { AnnotationAttributes lazy = attributesFor(metadata, Lazy.class); //如果Bean定义中有@Lazy注解，则将该Bean预实例化属性设置为@lazy注解的值 if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\"value\")); } else if (abd.getMetadata() != metadata) { lazy = attributesFor(abd.getMetadata(), Lazy.class); if (lazy != null) { abd.setLazyInit(lazy.getBoolean(\"value\")); } } //如果Bean定义中有@Primary注解，则为该Bean设置为autowiring自动依赖注入装配的首选对象 if (metadata.isAnnotated(Primary.class.getName())) { abd.setPrimary(true); } //如果Bean定义中有@ DependsOn注解，则为该Bean设置所依赖的Bean名称， //容器将确保在实例化该Bean之前首先实例化所依赖的Bean AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class); if (dependsOn != null) { abd.setDependsOn(dependsOn.getStringArray(\"value\")); } if (abd instanceof AbstractBeanDefinition) { AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd; AnnotationAttributes role = attributesFor(metadata, Role.class); if (role != null) { absBd.setRole(role.getNumber(\"value\").intValue()); } AnnotationAttributes description = attributesFor(metadata, Description.class); if (description != null) { absBd.setDescription(description.getString(\"value\")); } } } 4)、AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略 AnnotationConfigUtils 类的 applyScopedProxyMode()方法根据注解 Bean 定义类中配置的作用域@Scope 注解的值，为 Bean 定义应用相应的代理模式，主要是在 Spring 面向切面编程(AOP)中使用。源码如下： 123456789101112131415//根据作用域为Bean应用引用的代码模式 static BeanDefinitionHolder applyScopedProxyMode( ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) { //获取注解Bean定义类中@Scope注解的proxyMode属性值 ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode(); //如果配置的@Scope注解的proxyMode属性值为NO，则不应用代理模式 if (scopedProxyMode.equals(ScopedProxyMode.NO)) { return definition; } //获取配置的@Scope注解的proxyMode属性值，如果为TARGET_CLASS //则返回true，如果为INTERFACES，则返回false boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS); //为注册的Bean创建相应模式的代理对象 return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass); } 这段为 Bean 引用创建相应模式的代理，这里不做深入的分析。 5)、BeanDefinitionReaderUtils 向容器注册 Bean BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理BeanDefinition 的 HashMap 中。 扫描指定包并解析为 BeanDefinition 当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的包及其子包，将扫描到的注解 Bean 定义载入并注册。 1)、ClassPathBeanDefinitionScanner 扫描给定的包及其子包 AnnotationConfigApplicationContext 通过调用类路径Bean定义扫描器ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//创建一个类路径Bean定义扫描器public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { this(registry, true);}//为容器创建一个类路径Bean定义扫描器，并指定是否使用默认的扫描过滤规则。//即Spring默认扫描配置：@Component、@Repository、@Service、@Controller//注解的Bean，同时也支持JavaEE6的@ManagedBean和JSR-330的@Named注解public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) { this(registry, useDefaultFilters, getOrCreateEnvironment(registry));}public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment) { this(registry, useDefaultFilters, environment, (registry instanceof ResourceLoader ? (ResourceLoader) registry : null));}public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) { Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); //为容器设置加载Bean定义的注册器 this.registry = registry; if (useDefaultFilters) { registerDefaultFilters(); } setEnvironment(environment); //为容器设置资源加载器 setResourceLoader(resourceLoader);}//调用类路径Bean定义扫描器入口方法public int scan(String... basePackages) { //获取容器中已经注册的Bean个数 int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); //启动扫描器扫描给定包 doScan(basePackages); // Register annotation config processors, if necessary. //注册注解配置(Annotation config)处理器 if (this.includeAnnotationConfig) { AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } //返回注册的Bean个数 return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);}//类路径Bean定义扫描器扫描给定包及其子包protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); //创建一个集合，存放扫描到Bean定义的封装类 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;(); //遍历扫描所有给定的包 for (String basePackage : basePackages) { //调用父类ClassPathScanningCandidateComponentProvider的方法 //扫描给定类路径，获取符合条件的Bean定义 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); //遍历扫描到的Bean for (BeanDefinition candidate : candidates) { //获取Bean定义类中@Scope注解的值，即获取Bean的作用域 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); //为Bean设置注解配置的作用域 candidate.setScope(scopeMetadata.getScopeName()); //为Bean生成名称 String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); //如果扫描到的Bean不是Spring的注解Bean，则为Bean设置默认值， //设置Bean的自动依赖注入装配属性等 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } //如果扫描到的Bean是Spring的注解Bean，则处理其通用的Spring注解 if (candidate instanceof AnnotatedBeanDefinition) { //处理注解Bean中通用的注解，在分析注解Bean定义类读取器时已经分析过 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } //根据Bean名称检查指定的Bean是否需要在容器中注册，或者在容器中冲突 if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); //根据注解中配置的作用域，为Bean应用相应的代理模式 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //向容器注册扫描到的Bean registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions;} 类路径 Bean 定义扫描器 ClassPathBeanDefinitionScanner 主要通过findCandidateComponents()方法调用其父类 ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下的类。 2)、ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类 ClassPathScanningCandidateComponentProvider 类的 findCandidateComponents()方法具体实现扫描给定类路径包的功能，主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//扫描给定类路径的包public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) { return addCandidateComponentsFromIndex(this.componentsIndex, basePackage); } else { return scanCandidateComponents(basePackage); }}private Set&lt;BeanDefinition&gt; addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) { //创建存储扫描到的类的集合 Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); try { Set&lt;String&gt; types = new HashSet&lt;&gt;(); for (TypeFilter filter : this.includeFilters) { String stereotype = extractStereotype(filter); if (stereotype == null) { throw new IllegalArgumentException(\"Failed to extract stereotype from \"+ filter); } types.addAll(index.getCandidateTypes(basePackage, stereotype)); } boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (String type : types) { //为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type); //如果扫描到的类符合容器配置的过滤规则 if (isCandidateComponent(metadataReader)) { //通过汇编(ASM)读取资源字节码中的Bean定义元信息 AnnotatedGenericBeanDefinition sbd = new AnnotatedGenericBeanDefinition( metadataReader.getAnnotationMetadata()); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Using candidate component class from index: \" + type); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + type); } } } else { if (traceEnabled) { logger.trace(\"Ignored because matching an exclude filter: \" + type); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates;}private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\"Scanning \" + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Identified candidate component class: \" + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + resource); } } } else { if (traceEnabled) { logger.trace(\"Ignored because not matching any filter: \" + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); } } else { if (traceEnabled) { logger.trace(\"Ignored because not readable: \" + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates;} 注册注解 BeanDefinition AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版，它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean 定义源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//载入注解Bean定义资源@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) { //为容器设置注解Bean定义读取器 AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory); //为容器设置类路径Bean定义扫描器 ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory); //获取容器的Bean名称生成器 BeanNameGenerator beanNameGenerator = getBeanNameGenerator(); //为注解Bean定义读取器和类路径扫描器设置Bean名称生成器 if (beanNameGenerator != null) { reader.setBeanNameGenerator(beanNameGenerator); scanner.setBeanNameGenerator(beanNameGenerator); beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator); } //获取容器的作用域元信息解析器 ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver(); //为注解Bean定义读取器和类路径扫描器设置作用域元信息解析器 if (scopeMetadataResolver != null) { reader.setScopeMetadataResolver(scopeMetadataResolver); scanner.setScopeMetadataResolver(scopeMetadataResolver); } if (!this.annotatedClasses.isEmpty()) { if (logger.isInfoEnabled()) { logger.info(\"Registering annotated classes: [\" + StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + \"]\"); } reader.register(this.annotatedClasses.toArray(new Class&lt;?&gt;[this.annotatedClasses.size()])); } if (!this.basePackages.isEmpty()) { if (logger.isInfoEnabled()) { logger.info(\"Scanning base packages: [\" + StringUtils.collectionToCommaDelimitedString(this.basePackages) + \"]\"); } scanner.scan(this.basePackages.toArray(new String[this.basePackages.size()])); } //获取容器定义的Bean定义资源路径 String[] configLocations = getConfigLocations(); //如果定位的Bean定义资源路径不为空 if (configLocations != null) { for (String configLocation : configLocations) { try { //使用当前容器的类加载器加载定位路径的字节码类文件 Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader()); if (logger.isInfoEnabled()) { logger.info(\"Successfully resolved class for [\" + configLocation + \"]\"); } reader.register(clazz); } catch (ClassNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(\"Could not load class for config location [\" + configLocation + \"] - trying package scan. \" + ex); } //如果容器类加载器加载定义路径的Bean定义资源失败 //则启用容器类路径扫描器扫描给定路径包及其子包中的类 int count = scanner.scan(configLocation); if (logger.isInfoEnabled()) { if (count == 0) { logger.info(\"No annotated classes found for specified class/package [\" + configLocation + \"]\"); } else { logger.info(\"Found \" + count + \" annotated classes in package [\" + configLocation + \"]\"); } } } } }} 容器初始化小结 现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤：1、初始化的入口在容器实现中的 refresh()调用来完成。2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition(),其中的大致过程如下：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等方式来定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源，也就是说Bean定义文件时通过抽象成Resource来被IOC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册,往往使用的是XmlBeanDefinitionReader 来解析Bean的XML定义文件 - 实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用BeanDefinition对象来表示-这个名字可以让我们想到loadBeanDefinition(),registerBeanDefinition()这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有Bean 信息的场所，以后对 Bean 的操作都是围绕这个 HashMap 来实现的。然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring本身提供了对声明式载入web应用程序用法的应用程序上下文,并将其存储在ServletContext中的框架实现。以下是容器初始化全过程的时序图：","link":"/2019/08/21/Spring-2019-08-渐入Spring-IOC/"},{"title":"渐入Spring-DI","text":"Spring 自动装配之依赖注入一、依赖注入发生的时间当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生： 用户第一次调用 getBean()方法时，IOC 容器触发依赖注入。 当用户在配置文件中将&lt;bean&gt;元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。 BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和最基本的编程规范。BeanFactory 接口中定义了几个 getBean()方法，就是用户向 IOC 容器索取管理的Bean 的方法，我们通过分析其子类的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入。 在 BeanFactory 中我们可以看到 getBean(String…)方法，但它具体实现在 AbstractBeanFactory 中。 二、寻找获取Bean的入口AbstractBeanFactory 的 getBean()相关方法的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228//---------------------------------------------------------------------// Implementation of BeanFactory interface//---------------------------------------------------------------------//获取IOC容器中指定名称的Bean@Overridepublic Object getBean(String name) throws BeansException { //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, null, null, false);}//获取IOC容器中指定名称和类型的Bean@Overridepublic &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException { //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, requiredType, null, false);}//获取IOC容器中指定名称和参数的Bean@Overridepublic Object getBean(String name, Object... args) throws BeansException { //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, null, args, false);}//获取IOC容器中指定名称、类型和参数的Beanpublic &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException { //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, requiredType, args, false);}@SuppressWarnings(\"unchecked\")//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. //先从缓存中取是否已经有被创建过的单态类型的Bean //对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IOC容器创建单例模式Bean实例对象 if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { //如果指定名称的Bean在容器中已有单例模式的Bean被创建 //直接返回已经创建的Bean if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); } else { logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); } } //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是 //创建创建对象的工厂Bean，两者之间有区别 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. //缓存没有正在创建的单例模式Bean //缓存中已经有已经创建的原型模式Bean //但是由于循环引用的问题导致实例化对象失败 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // Check if bean definition exists in this factory. //对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找 BeanFactory parentBeanFactory = getParentBeanFactory(); //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // Not found -&gt; check parent. //解析指定Bean名称的原始名称 String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. //委派父级容器根据指定名称和显式的参数查找 return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // No args -&gt; delegate to standard getBean method. //委派父级容器根据指定名称和类型查找 return parentBeanFactory.getBean(nameToLookup, requiredType); } } //创建的Bean是否需要进行类型验证，一般不需要 if (!typeCheckOnly) { //向容器标记指定的Bean已经被创建 markBeanAsCreated(beanName); } try { //根据指定Bean名称获取其父级的Bean定义 //主要解决Bean继承时子类合并父类公共属性问题 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. //获取当前Bean所有依赖Bean的名称 String[] dependsOn = mbd.getDependsOn(); //如果当前Bean有依赖Bean if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); } //递归调用getBean方法，获取当前Bean的依赖Bean registerDependentBean(dep, beanName); //把被依赖Bean注册给当前依赖的Bean getBean(dep); } } // Create bean instance. //创建单例模式Bean的实例对象 if (mbd.isSingleton()) { //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象 sharedInstance = getSingleton(beanName, () -&gt; { try { //创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. //显式地从容器单例模式Bean缓存中清除实例对象 destroySingleton(beanName); throw ex; } }); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } //IOC容器创建原型模式Bean实例对象 else if (mbd.isPrototype()) { // It's a prototype -&gt; create a new instance. //原型模式(Prototype)是每次都会创建一个新的对象 Object prototypeInstance = null; try { //回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象 beforePrototypeCreation(beanName); //创建指定Bean对象实例 prototypeInstance = createBean(beanName, mbd, args); } finally { //回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建 afterPrototypeCreation(beanName); } //获取给定Bean的实例对象 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } //要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中 //比较常用，如：request、session、application等生命周期 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); //Bean定义资源中没有配置生命周期范围，则Bean定义不合法 if (scope == null) { throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); } try { //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例 Object scopedInstance = scope.get(beanName, () -&gt; { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // Check if required type matches the type of the actual bean instance. //对创建的Bean实例对象进行类型检查 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { try { T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) { throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } return convertedBean; } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean;} 通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以扩展为指定其生命周期范围。上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean实例对象的创建过程由实现了 ObjectFactory 接口的匿名内部类的 createBean()方法完成，ObjectFactory使用委派模式, 具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成. 我们继续分析AbstractAutowireCapableBeanFactory的createBean()方法的源码, 理解其创建Bean实例的具体实现过程. 三、开始实例化AbstractAutowireCapableBeanFactory 类实现了 ObjectFactory 接口，创建容器指定的 Bean 实例对象，同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//创建Bean实例对象@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (logger.isDebugEnabled()) { logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); } RootBeanDefinition mbdToUse = mbd; //判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } //校验和准备Bean中的方法覆盖 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); } try { //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); } try { //创建Bean的入口 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) { logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); } return beanInstance; } catch (BeanCreationException ex) { // A previously detected exception with proper bean creation context already... throw ex; } catch (ImplicitlyAppearedSingletonException ex) { // An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry... throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex); }}//真正创建Bean的方法protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. //封装被创建的Bean对象 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); //获取实例化对象的类型 Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. //调用PostProcessor后置处理器 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. //向容器中缓存单例模式的Bean对象，以防循环引用 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. //Bean对象的初始化，依赖注入在此触发 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean Object exposedObject = bean; try { //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象 populateBean(beanName, mbd, instanceWrapper); //初始化Bean对象 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { //获取指定名称的已注册的单例模式Bean对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { //根据名称获取的已注册的Bean和正在实例化的Bean是同一个 if (exposedObject == bean) { //当前实例化的Bean初始化完成 exposedObject = earlySingletonReference; } //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); //获取当前Bean所依赖的其他Bean for (String dependentBean : dependentBeans) { //对依赖Bean进行类型检查 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. //注册完成依赖注入的Bean try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject;} 我们看到具体的依赖注入实现其实就在以下两个方法中： createBeanInstance()方法，生成 Bean 所包含的 java 对象实例。 populateBean()方法，对 Bean 属性的依赖注入进行处理。 下面继续分析这两个方法的代码实现。 四、选择Bean实例化策略在 createBeanInstance()方法中，根据指定的初始化策略，使用简单工厂、工厂方法或者容器的自动装配特性生成 Java 实例对象，创建对象的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//创建Bean的实例对象protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // Make sure bean class is actually resolved at this point. //检查确认Bean是可实例化的 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); //使用工厂方法对Bean进行实例化 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } if (mbd.getFactoryMethodName() != null) { //调用工厂方法实例化 return instantiateUsingFactoryMethod(beanName, mbd, args); } // Shortcut when re-creating the same bean... //使用容器的自动装配方法进行实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { //配置了自动装配属性，使用容器的自动装配实例化 //容器的自动装配是根据参数类型匹配Bean的构造方法 return autowireConstructor(beanName, mbd, null, null); } else { //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd); } } // Need to determine the constructor... //使用Bean的构造方法进行实例化 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { //使用容器的自动装配特性，调用匹配的构造方法实例化 return autowireConstructor(beanName, mbd, ctors, args); } // No special handling: simply use no-arg constructor. //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd);}//使用默认的无参构造方法实例化Bean对象protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; //获取系统的安全管理接口，JDK标准的安全管理API if (System.getSecurityManager() != null) { //这里是一个匿名内置类，根据实例化策略创建实例对象 beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, parent), getAccessControlContext()); } else { //将实例化的对象封装起来 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); }} 我们可以看出, 对使用工厂方法和自动装配特性的 Bean 的实例化相对比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLib)来进行初始化了，在方法 getInstantiationStrategy().instantiate()中就具体实现类使用初始策略实例化对象。 1234567891011121314151617181920212223242526272829303132333435363738394041//使用初始化策略实例化Bean对象@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) { // Don't override the class with CGLIB if no overrides. //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法 if (!bd.hasMethodOverrides()) { Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) { //获取对象的构造方法或工厂方法 constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; //如果没有构造方法且没有工厂方法 if (constructorToUse == null) { //使用JDK的反射机制，判断要实例化的Bean是否是接口 final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); } try { if (System.getSecurityManager() != null) { //这里是一个匿名内置类，使用反射机制获取Bean的构造方法 constructorToUse = AccessController.doPrivileged( (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor()); } else { constructorToUse = clazz.getDeclaredConstructor(); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable ex) { throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); } } } //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化 return BeanUtils.instantiateClass(constructorToUse); }else { // Must generate CGLIB subclass. //使用CGLIB来实例化对象 return instantiateWithMethodInjection(bd, beanName, owner); }} CGLib 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 Java 字节码的生成和转换功能。 五、准备依赖注入在前面的分析中我们已经了解到 Bean 的依赖注入主要分为两个步骤，首先调用 createBeanInstance()方法生成 Bean 所包含的 Java 对象实例。然后，调用 populateBean()方法，对 Bean 属性的依赖注入进行处理。上面我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析生成对象后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，回到AbstractAutowireCapableBeanFactory 的 populateBean()方法，对属性依赖注入的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//将Bean属性设置到生成的实例对象上protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); //对依赖注入处理，首先处理autowiring自动装配的依赖注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. //根据Bean名称进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. //根据Bean类型进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } //对非autowiring的属性进行依赖注入处理 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) { if (pvs == null) { pvs = mbd.getPropertyValues(); } PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { checkDependencies(beanName, mbd, filteredPds, pvs); } } if (pvs != null) { //对属性进行注入 applyPropertyValues(beanName, mbd, bw, pvs); }} 分析上述代码，我们可以看出，对属性的注入过程分以下两种情况： 属性值类型不需要强制转换时，不需要解析属性值，直接准备进行依赖注入。 属性值需要进行类型强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。 对属性值的解析是在BeanDefinitionValueResolver类中的resolveValueIfNecessary()方法中进行的，对属性值的依赖注入是通过 bw.setPropertyValues()方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程。 六 、解析属性注入规则当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary()方法实现，其源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//解析属性值，对注入类型进行转换@Nullablepublic Object resolveValueIfNecessary(Object argName, @Nullable Object value) { // We must check each value to see whether it requires a runtime reference // to another bean to be resolved. //对引用类型的属性进行解析 if (value instanceof RuntimeBeanReference) { RuntimeBeanReference ref = (RuntimeBeanReference) value; //调用引用类型属性的解析方法 return resolveReference(argName, ref); } //对属性值是引用容器中另一个Bean名称的解析 else if (value instanceof RuntimeBeanNameReference) { String refName = ((RuntimeBeanNameReference) value).getBeanName(); refName = String.valueOf(doEvaluate(refName)); //从容器中获取指定名称的Bean if (!this.beanFactory.containsBean(refName)) { throw new BeanDefinitionStoreException( \"Invalid bean name '\" + refName + \"' in bean reference for \" + argName); } return refName; } //对Bean类型属性的解析，主要是Bean中的内部类 else if (value instanceof BeanDefinitionHolder) { // Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases. BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value; return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition()); } else if (value instanceof BeanDefinition) { // Resolve plain BeanDefinition, without contained name: use dummy name. BeanDefinition bd = (BeanDefinition) value; String innerBeanName = \"(inner bean)\" + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(bd); return resolveInnerBean(argName, innerBeanName, bd); } //对集合数组类型的属性解析 else if (value instanceof ManagedArray) { // May need to resolve contained runtime references. ManagedArray array = (ManagedArray) value; //获取数组的类型 Class&lt;?&gt; elementType = array.resolvedElementType; if (elementType == null) { //获取数组元素的类型 String elementTypeName = array.getElementTypeName(); if (StringUtils.hasText(elementTypeName)) { try { //使用反射机制创建指定类型的对象 elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader()); array.resolvedElementType = elementType; } catch (Throwable ex) { // Improve the message by showing the context. throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Error resolving array type for \" + argName, ex); } } //没有获取到数组的类型，也没有获取到数组元素的类型 //则直接设置数组的类型为Object else { elementType = Object.class; } } //创建指定类型的数组 return resolveManagedArray(argName, (List&lt;?&gt;) value, elementType); } //解析list类型的属性值 else if (value instanceof ManagedList) { // May need to resolve contained runtime references. return resolveManagedList(argName, (List&lt;?&gt;) value); } //解析set类型的属性值 else if (value instanceof ManagedSet) { // May need to resolve contained runtime references. return resolveManagedSet(argName, (Set&lt;?&gt;) value); } //解析map类型的属性值 else if (value instanceof ManagedMap) { // May need to resolve contained runtime references. return resolveManagedMap(argName, (Map&lt;?, ?&gt;) value); } //解析props类型的属性值，props其实就是key和value均为字符串的map else if (value instanceof ManagedProperties) { Properties original = (Properties) value; //创建一个拷贝，用于作为解析后的返回值 Properties copy = new Properties(); original.forEach((propKey, propValue) -&gt; { if (propKey instanceof TypedStringValue) { propKey = evaluate((TypedStringValue) propKey); } if (propValue instanceof TypedStringValue) { propValue = evaluate((TypedStringValue) propValue); } if (propKey == null || propValue == null) { throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Error converting Properties key/value pair for \" + argName + \": resolved to null\"); } copy.put(propKey, propValue); }); return copy; } //解析字符串类型的属性值 else if (value instanceof TypedStringValue) { // Convert value to target type here. TypedStringValue typedStringValue = (TypedStringValue) value; Object valueObject = evaluate(typedStringValue); try { //获取属性的目标类型 Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue); if (resolvedTargetType != null) { //对目标类型的属性进行解析，递归调用 return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType); } //没有获取到属性的目标对象，则按Object类型返回 else { return valueObject; } } catch (Throwable ex) { // Improve the message by showing the context. throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Error converting typed String value for \" + argName, ex); } } else if (value instanceof NullBean) { return null; } else { return evaluate(value); }}//解析引用类型的属性值@Nullableprivate Object resolveReference(Object argName, RuntimeBeanReference ref) { try { Object bean; //获取引用的Bean名称 String refName = ref.getBeanName(); refName = String.valueOf(doEvaluate(refName)); //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象 if (ref.isToParent()) { if (this.beanFactory.getParentBeanFactory() == null) { throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Can't resolve reference to bean '\" + refName + \"' in parent factory: no parent factory available\"); } bean = this.beanFactory.getParentBeanFactory().getBean(refName); } //从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化 //则会递归触发引用Bean的初始化和依赖注入 else { bean = this.beanFactory.getBean(refName); //将当前实例化对象的依赖引用对象 this.beanFactory.registerDependentBean(refName, this.beanName); } if (bean instanceof NullBean) { bean = null; } return bean; } catch (BeansException ex) { throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Cannot resolve reference to bean '\" + ref.getBeanName() + \"' while setting \" + argName, ex); }}/** * For each element in the managed array, resolve reference if necessary. *///解析array类型的属性private Object resolveManagedArray(Object argName, List&lt;?&gt; ml, Class&lt;?&gt; elementType) { //创建一个指定类型的数组，用于存放和返回解析后的数组 Object resolved = Array.newInstance(elementType, ml.size()); for (int i = 0; i &lt; ml.size(); i++) { //递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i Array.set(resolved, i, resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i))); } return resolved;} 通过上面的代码分析，我们明白了 Spring 是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean对象属性上去。而真正的依赖注入是通过 bw.setPropertyValues()方法实现的，该方法也使用了委托模式 ， 在 BeanWrapper 接口中至少定义了方法声明，依赖注入具体实现交由其实现类BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。 七、注入赋值BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean对象设置到它所依赖的另一个 Bean 的属性中去。然而，BeanWrapperImpl 中的注入方法实际上由AbstractNestablePropertyAccessor 来实现的，其相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198//实现属性依赖注入功能protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException { if (tokens.keys != null) { processKeyedProperty(tokens, pv); } else { processLocalProperty(tokens, pv); }}//实现属性依赖注入功能@SuppressWarnings(\"unchecked\")private void processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) { //调用属性的getter方法，获取属性的值 Object propValue = getPropertyHoldingValue(tokens); PropertyHandler ph = getLocalPropertyHandler(tokens.actualName); if (ph == null) { throw new InvalidPropertyException( getRootClass(), this.nestedPath + tokens.actualName, \"No property handler found\"); } Assert.state(tokens.keys != null, \"No token keys\"); String lastKey = tokens.keys[tokens.keys.length - 1]; //注入array类型的属性值 if (propValue.getClass().isArray()) { Class&lt;?&gt; requiredType = propValue.getClass().getComponentType(); int arrayIndex = Integer.parseInt(lastKey); Object oldValue = null; try { if (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) { oldValue = Array.get(propValue, arrayIndex); } Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length)); //获取集合类型属性的长度 int length = Array.getLength(propValue); if (arrayIndex &gt;= length &amp;&amp; arrayIndex &lt; this.autoGrowCollectionLimit) { Class&lt;?&gt; componentType = propValue.getClass().getComponentType(); Object newArray = Array.newInstance(componentType, arrayIndex + 1); System.arraycopy(propValue, 0, newArray, 0, length); setPropertyValue(tokens.actualName, newArray); //调用属性的getter方法，获取属性的值 propValue = getPropertyValue(tokens.actualName); } //将属性的值赋值给数组中的元素 Array.set(propValue, arrayIndex, convertedValue); } catch (IndexOutOfBoundsException ex) { //... } } //注入list类型的属性值 else if (propValue instanceof List) { //获取list集合的类型 Class&lt;?&gt; requiredType = ph.getCollectionType(tokens.keys.length); List&lt;Object&gt; list = (List&lt;Object&gt;) propValue; //获取list集合的size int index = Integer.parseInt(lastKey); Object oldValue = null; if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) { oldValue = list.get(index); } //获取list解析后的属性值 Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length)); int size = list.size(); //如果list的长度大于属性值的长度，则多余的元素赋值为null if (index &gt;= size &amp;&amp; index &lt; this.autoGrowCollectionLimit) { for (int i = size; i &lt; index; i++) { try { list.add(null); } catch (NullPointerException ex) { // ... } } list.add(convertedValue); } else { try { //将值添加到list中 list.set(index, convertedValue); } catch (IndexOutOfBoundsException ex) { // ... } } } //注入map类型的属性值 else if (propValue instanceof Map) { //获取map集合key的类型 Class&lt;?&gt; mapKeyType = ph.getMapKeyType(tokens.keys.length); //获取map集合value的类型 Class&lt;?&gt; mapValueType = ph.getMapValueType(tokens.keys.length); Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) propValue; // IMPORTANT: Do not pass full property name in here - property editors // must not kick in for map keys but rather only for map values. TypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType); //解析map类型属性key值 Object convertedMapKey = convertIfNecessary(null, null, lastKey, mapKeyType, typeDescriptor); Object oldValue = null; if (isExtractOldValueForEditor()) { oldValue = map.get(convertedMapKey); } // Pass full property name and old value in here, since we want full // conversion ability for map values. //解析map类型属性value值 Object convertedMapValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length)); //将解析后的key和value值赋值给map集合属性 map.put(convertedMapKey, convertedMapValue); } else { throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,\"...\"); }}private Object getPropertyHoldingValue(PropertyTokenHolder tokens) { // Apply indexes and map keys: fetch value for all keys but the last one. Assert.state(tokens.keys != null, \"No token keys\"); PropertyTokenHolder getterTokens = new PropertyTokenHolder(tokens.actualName); getterTokens.canonicalName = tokens.canonicalName; getterTokens.keys = new String[tokens.keys.length - 1]; System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1); Object propValue; try { //获取属性值 propValue = getPropertyValue(getterTokens); } catch (NotReadablePropertyException ex) { ... } if (propValue == null) { // null map value case if (isAutoGrowNestedPaths()) { int lastKeyIndex = tokens.canonicalName.lastIndexOf('['); getterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex); propValue = setDefaultValue(getterTokens); } else { throw new NullValueInNestedPathException(...); } } return propValue;}private void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) { PropertyHandler ph = getLocalPropertyHandler(tokens.actualName); if (ph == null || !ph.isWritable()) { if (pv.isOptional()) { if (logger.isDebugEnabled()) { logger.debug(\"...\"); } return; } else { throw createNotWritablePropertyException(tokens.canonicalName); } } Object oldValue = null; try { Object originalValue = pv.getValue(); Object valueToApply = originalValue; if (!Boolean.FALSE.equals(pv.conversionNecessary)) { if (pv.isConverted()) { valueToApply = pv.getConvertedValue(); } else { if (isExtractOldValueForEditor() &amp;&amp; ph.isReadable()) { try { oldValue = ph.getValue(); } catch (Exception ex) { if (ex instanceof PrivilegedActionException) { ex = ((PrivilegedActionException) ex).getException(); } if (logger.isDebugEnabled()) { logger.debug(\"...); } } } valueToApply = convertForProperty( tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor()); } pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue); } ph.setValue(valueToApply); } catch (TypeMismatchException ex) { // ... }} 通过对上面注入依赖代码的分析，我们已经明白了 Spring IOC 容器是如何将属性的值注入到 Bean 实例对象中去的： 对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。 对于非集合类型的属性，大量使用了 JDK 的反射机制，通过属性的 getter()方法获取指定属性注入以前的值，同时调用属性的 setter()方法为属性设置注入后的值。 至此 Spring IOC 容器对 Bean 定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IOC 容器中管理了一系列靠依赖关系联系起来的 Bean，程序不需要应用自己手动创建所需的对象，Spring IOC 容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是Spring 核心功能的控制反转和依赖注入的相关功能。 IOC 容器中那些鲜为人知的细节通过前面章节中对 Spring IOC 容器的源码分析，我们已经基本上了解了 Spring IOC 容器对 Bean 定义资源的定位、载入和注册过程，同时也清楚了当用户通过 getBean()方法向 IOC 容器获取被管理的 Bean时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者修饰 Bean 对象的生成、IOC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声明周期事件管理等。 一、关于延时加载通过前面我们对 IOC 容器的实现和工作原理分析，我们已经知道 IOC 容器的初始化过程就是对 Bean定义资源的定位、载入和注册，此时容器对 Bean 的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取 Bean 时，通过 getBean()方法的调用完成。当 Bean 定义资源的&lt;Bean&gt;元素中配置了lazy-init=false属性时，容器将会在初始化的时候对所配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完成依赖注入的现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。 1. refresh()方法先从 IOC 容器的初始化过程开始，我们知道 IOC 容器读入已经定位的 Bean 定义资源是从 refresh()方法开始的，我们首先从 AbstractApplicationContext 类的 refresh()方法入手分析，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. //1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //3、为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. //4、为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //5、调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //6、为BeanFactory注册BeanPost事件处理器. //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //7、初始化信息源，和国际化相关. initMessageSource(); // Initialize event multicaster for this context. //8、初始化容器事件传播器. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //9、调用子类的某些特殊Bean初始化方法 onRefresh(); // Check for listener beans and register them. //10、为事件传播器注册事件监听器. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //11、初始化所有剩余的单例Bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { //... } // Destroy already created singletons to avoid dangling resources. //13、销毁已创建的Bean destroyBeans(); // Reset 'active' flag. //14、取消refresh操作，重置容器的同步标识。 cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... //15、重设公共缓存 resetCommonCaches(); } }} 在 refresh()方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了 Bean 定义资源的载入、注册过程，而 finishBeanFactoryInitialization 方法是对注册后的 Bean定义中的预实例化(lazy-init=false,Spring 默认就是预实例化,即为 true)的 Bean 进行处理的地方。 2. finishBeanFactoryInitialization 处理预实例化 Bean当 Bean 定义资源被载入 IOC 容器之后，容器将 Bean 定义资源解析为容器内部的数据结构BeanDefinition注册到容器中，AbstractApplicationContext类中的finishBeanFactoryInitialization()方法对配置了预实例化属性的 Bean 进行预初始化过程，源码如下： 123456789101112131415161718192021222324252627282930313233343536//对配置了lazy-init属性的Bean进行预实例化处理protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // Initialize conversion service for this context. //这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService) //在对某些Bean属性进行转换时使用 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); } // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early. String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. //为了类型匹配，停止使用临时的类加载器 beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. //缓存容器中所有注册的BeanDefinition元数据，以防被修改 beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. //对配置了lazy-init属性的单态模式Bean进行预实例化处理 beanFactory.preInstantiateSingletons();} ConfigurableListableBeanFactory 是一个接口 ， 其 preInstantiateSingletons() 方法由其子类DefaultListableBeanFactory 提供。 3. DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//对配置lazy-init属性单态Bean的预实例化@Overridepublic void preInstantiateSingletons() throws BeansException { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Pre-instantiating singletons in \" + this); } List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) { //获取指定名称的Bean定义 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); //Bean不是抽象的，是单态模式的，且lazy-init属性配置为false if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { //如果指定名称的bean是创建容器的Bean if (isFactoryBean(beanName)) { //FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号 //时，获取的是产生容器对象本身，而不是容器产生的Bean. //调用getBean方法，触发容器对Bean实例化和依赖注入过程 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); //标识是否需要预实例化 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { //一个匿名内部类 isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(), getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { //调用getBean方法，触发容器对Bean实例化和依赖注入过程 getBean(beanName); } } else { getBean(beanName); } } } // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } }} 通过对 lazy-init 处理源码的分析，我们可以看出，如果设置了 lazy-init 属性，则容器在完成 Bean 定义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程，这样当应用第一次向容器索取所需的 Bean 时，容器不再需要对 Bean 进行初始化和依赖注入，直接从已经完成实例化和依赖注入的 Bean 中取一个现成的 Bean，这样就提高了第一次获取 Bean 的性能。 二、关于FactoryBean和BeanFactory1. BeanFactoryBean 工厂，是一个工厂(Factory)，我们 Spring IOC 容器的最顶层接口就是这个BeanFactory，它的作用是管理 Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 2. FactoryBean工厂 Bean，是一个 Bean，作用是产生其他 bean 实例。通常情况下，这种 Bean 没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他 Bean 实例。通常情况下，Bean 无须自己实现工厂模式，Spring 容器担任工厂角色；但少数情况下，容器中的 Bean 本身就是工厂，其作用是产生其它 Bean 实例。 当用户使用容器本身时，可以使用转义字符”&amp;”来得到 FactoryBean 本身，以区别通过 FactoryBean产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符： 1String FACTORY_BEAN_PREFIX = \"&amp;\"; 如果 myJndiObject 是一个 FactoryBean，则使用&amp;myJndiObject 得到的是 myJndiObject 对象，而不是myJndiObject 产生出来的对象。 a. FactoryBean 源码12345678910111213141516171819//工厂Bean，用于产生其他对象public interface FactoryBean&lt;T&gt; { //获取容器管理的对象实例 @Nullable T getObject() throws Exception; //获取Bean工厂创建的对象的类型 @Nullable Class&lt;?&gt; getObjectType(); //Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例 //对象，每次请求都返回同一个实例对象 default boolean isSingleton() { return true; }} b. AbstractBeanFactory 的 getBean()方法调用 FactoryBean在前面我们分析 Spring IOC 容器实例化 Bean 并进行依赖注入过程的源码时，提到在 getBean()方法触发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean()方法来进行实例化的过程，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. //先从缓存中取是否已经有被创建过的单态类型的Bean //对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IOC容器创建单例模式Bean实例对象 if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { //如果指定名称的Bean在容器中已有单例模式的Bean被创建 //直接返回已经创建的Bean if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); } else { logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); } } //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是 //创建创建对象的工厂Bean，两者之间有区别 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. //缓存没有正在创建的单例模式Bean //缓存中已经有已经创建的原型模式Bean //但是由于循环引用的问题导致实例化对象失败 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // Check if bean definition exists in this factory. //对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找 BeanFactory parentBeanFactory = getParentBeanFactory(); //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // Not found -&gt; check parent. //解析指定Bean名称的原始名称 String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. //委派父级容器根据指定名称和显式的参数查找 return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // No args -&gt; delegate to standard getBean method. //委派父级容器根据指定名称和类型查找 return parentBeanFactory.getBean(nameToLookup, requiredType); } } //创建的Bean是否需要进行类型验证，一般不需要 if (!typeCheckOnly) { //向容器标记指定的Bean已经被创建 markBeanAsCreated(beanName); } try { //根据指定Bean名称获取其父级的Bean定义 //主要解决Bean继承时子类合并父类公共属性问题 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. //获取当前Bean所有依赖Bean的名称 String[] dependsOn = mbd.getDependsOn(); //如果当前Bean有依赖Bean if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); } //递归调用getBean方法，获取当前Bean的依赖Bean registerDependentBean(dep, beanName); //把被依赖Bean注册给当前依赖的Bean getBean(dep); } } // Create bean instance. //创建单例模式Bean的实例对象 if (mbd.isSingleton()) { //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象 sharedInstance = getSingleton(beanName, () -&gt; { try { //创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义 return createBean(beanName, mbd, args); } catch (BeansException ex) { //显式地从容器单例模式Bean缓存中清除实例对象 destroySingleton(beanName); throw ex; } }); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } //IOC容器创建原型模式Bean实例对象 else if (mbd.isPrototype()) { // It's a prototype -&gt; create a new instance. //原型模式(Prototype)是每次都会创建一个新的对象 Object prototypeInstance = null; try { //回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象 beforePrototypeCreation(beanName); //创建指定Bean对象实例 prototypeInstance = createBean(beanName, mbd, args); } finally { //回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建 afterPrototypeCreation(beanName); } //获取给定Bean的实例对象 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } //要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中 //比较常用，如：request、session、application等生命周期 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); //Bean定义资源中没有配置生命周期范围，则Bean定义不合法 if (scope == null) { throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); } try { //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例 Object scopedInstance = scope.get(beanName, () -&gt; { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // Check if required type matches the type of the actual bean instance. //对创建的Bean实例对象进行类型检查 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { try { T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) { throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } return convertedBean; } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean;}//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // Don't let calling code try to dereference the factory if the bean isn't a factory. //容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean， //也可能是一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象， //如果调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象 //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)， //且Bean实例也不是创建Bean实例对象的工厂Bean if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) { throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); } // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it's a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. //如果Bean实例不是工厂Bean，或者指定名称是容器的解引用， //调用者向获取对容器的引用，则直接返回当前的Bean实例 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { return beanInstance; } //处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean //使用工厂Bean创建一个Bean的实例对象 Object object = null; if (mbd == null) { //从Bean工厂缓存中获取给定名称的Bean实例对象 object = getCachedObjectForFactoryBean(beanName); } //让Bean工厂生产给定名称的Bean对象实例 if (object == null) { // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. //如果从Bean工厂生产的Bean是单态模式的，则缓存 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) { //从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性 mbd = getMergedLocalBeanDefinition(beanName); } //如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的， //则让工厂Bean生产Bean实例对象 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); //调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean方法， //实现工厂Bean生产Bean对象实例的过程 object = getObjectFromFactoryBean(factory, beanName, !synthetic); } return object;} 在上面获取给定Bean的实例对象的getObjectForBeanInstance() 方法中,会调用FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean()方法，该方法实现了 Bean 工厂生产 Bean 实例对象。 Dereference(解引用)：一个在 C/C++中应用比较多的术语，在 C++中，”*”是解引用符号，而”&amp;”是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。 c. AbstractBeanFactory 生产 Bean 实例对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Bean工厂生产Bean实例对象protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) { //Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) { //多线程同步，以防止数据不一致 synchronized (getSingletonMutex()) { //直接从Bean工厂缓存中获取指定名称的Bean实例对象 Object object = this.factoryBeanObjectCache.get(beanName); //Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象 if (object == null) { //调用Bean工厂的getObject方法生产指定Bean的实例对象 object = doGetObjectFromFactoryBean(factory, beanName); // Only post-process and store if not put there already during getObject() call above // (e.g. because of circular reference processing triggered by custom getBean calls) Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { object = alreadyThere; } else { if (shouldPostProcess) { try { object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's singleton object failed\", ex); } } //将生产的实例对象添加到Bean工厂缓存中 this.factoryBeanObjectCache.put(beanName, object); } } return object; } } //调用Bean工厂的getObject方法生产指定Bean的实例对象 else { Object object = doGetObjectFromFactoryBean(factory, beanName); if (shouldPostProcess) { try { object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex); } } return object; }}//调用Bean工厂的getObject方法生产指定Bean的实例对象private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) throws BeanCreationException { Object object; try { if (System.getSecurityManager() != null) { AccessControlContext acc = getAccessControlContext(); try { //实现PrivilegedExceptionAction接口的匿名内置类 //根据JVM检查权限，然后决定BeanFactory创建实例对象 object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; factory.getObject(), acc); } catch (PrivilegedActionException pae) { throw pae.getException(); } } else { //调用BeanFactory接口实现类的创建对象方法 object = factory.getObject(); } } catch (FactoryBeanNotInitializedException ex) { throw new BeanCurrentlyInCreationException(beanName, ex.toString()); } catch (Throwable ex) { throw new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex); } // Do not accept a null value for a FactoryBean that's not fully // initialized yet: Many FactoryBeans just return null then. //创建出来的实例对象为null，或者因为单态对象正在创建而返回null if (object == null) { if (isSingletonCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException( beanName, \"FactoryBean which is currently in creation returned null from getObject\"); } object = new NullBean(); } return object;} 从上面的源码分析中，我们可以看出，BeanFactory 接口调用其实现类的 getObject 方法来实现创建Bean 实例对象的功能。 d. 工厂 Bean 的实现类 getObject 方法创建 Bean 实例对象FactoryBean 的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean 等等，FactoryBean 接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject()有不同的实现类根据不同的实现策略来具体提供，我们分析一个最简单的 AnnotationTestBeanFactory 的实现源码： 12345678910111213141516171819202122232425public class AnnotationTestBeanFactory implements FactoryBean&lt;FactoryCreatedAnnotationTestBean&gt; { private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean(); public AnnotationTestBeanFactory() { this.instance.setName(\"FACTORY\"); } @Override public FactoryCreatedAnnotationTestBean getObject() throws Exception { return this.instance; } //AnnotationTestBeanFactory产生Bean实例对象的实现 @Override public Class&lt;? extends IJmxTestBean&gt; getObjectType() { return FactoryCreatedAnnotationTestBean.class; } @Override public boolean isSingleton() { return true; }} 其他的 Proxy，RMI，JNDI 等等，都是根据相应的策略提供 getObject()的实现。这里不做一一分析，这已经不是 Spring 的核心功能 三、再述autowiringSpring IOC 容器提供了两种管理 Bean 依赖关系的方式： 显式管理：通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。 autowiring：Spring IOC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IOC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。 通过对 autowiring 自动装配特性的理解，我们知道容器对 Bean 的自动装配发生在容器对 Bean 依赖注入的过程中。在前面对 Spring IOC 容器的依赖注入过程源码分析中，我们已经知道了容器对 Bean 实例对象的属性注入的处理发生在 AbstractAutoWireCapableBeanFactory 类中的 populateBean()方法中，我们通过程序流程分析 autowiring 的实现原理： 1. AbstractAutoWireCapableBeanFactory 对 Bean 实例进行属性依赖注入应用第一次通过 getBean()方法(配置了 lazy-init 预实例化属性的除外)向 IOC 容器索取 Bean 时，容器创建Bean实例对象， 并且对Bean实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory的populateBean()方法就是实现Bean属性依赖注入的功能,其主要源码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//将Bean属性设置到生成的实例对象上protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); } else { // Skip property population phase for null instance. return; } } boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); //对依赖注入处理，首先处理autowiring自动装配的依赖注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. //根据Bean名称进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. //根据Bean类型进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } //对非autowiring的属性进行依赖注入处理 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) { if (pvs == null) { pvs = mbd.getPropertyValues(); } PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { checkDependencies(beanName, mbd, filteredPds, pvs); } } if (pvs != null) { //对属性进行注入 applyPropertyValues(beanName, mbd, bw, pvs); }}//根据名称对属性进行自动依赖注入protected void autowireByName( String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) { //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等都是简单属性)进行处理 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); for (String propertyName : propertyNames) { //如果Spring IOC容器中包含指定名称的Bean if (containsBean(propertyName)) { //调用getBean方法向IOC容器索取指定名称的Bean实例，迭代触发属性的初始化和依赖注入 Object bean = getBean(propertyName); //为指定名称的属性赋予属性值 pvs.add(propertyName, bean); //指定名称属性注册依赖Bean名称，进行属性依赖注入 registerDependentBean(propertyName, beanName); if (logger.isDebugEnabled()) { logger.debug(\"Added autowiring by name from bean name '\" + beanName + \"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\"); } } else { if (logger.isTraceEnabled()) { logger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName + \"' by name: no matching bean found\"); } } }} 2. Spring IOC容器根据Bean名称或者类型进行autowiring自动依赖注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//根据类型对属性进行自动依赖注入protected void autowireByType( String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) { //获取用户定义的类型转换器 TypeConverter converter = getCustomTypeConverter(); if (converter == null) { converter = bw; } //存放解析的要注入的属性 Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4); //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符 //URL等都是简单属性)进行处理 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); for (String propertyName : propertyNames) { try { //获取指定属性名称的属性描述器 PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName); // Don't try autowiring by type for type Object: never makes sense, // even if it technically is a unsatisfied, non-simple property. //不对Object类型的属性进行autowiring自动依赖注入 if (Object.class != pd.getPropertyType()) { //获取属性的setter方法 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd); // Do not allow eager init for type matching in case of a prioritized post-processor. //检查指定类型是否可以被转换为目标对象的类型 boolean eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance()); //创建一个要被注入的依赖描述 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager); //根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter); if (autowiredArgument != null) { //为属性赋值所引用的对象 pvs.add(propertyName, autowiredArgument); } for (String autowiredBeanName : autowiredBeanNames) { //指定名称属性注册依赖Bean名称，进行属性依赖注入 registerDependentBean(autowiredBeanName, beanName); if (logger.isDebugEnabled()) { logger.debug(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" + propertyName + \"' to bean named '\" + autowiredBeanName + \"'\"); } } //释放已自动注入的属性 autowiredBeanNames.clear(); } } catch (BeansException ex) { throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex); } }} 我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些， 但是真正实现属性注入的是 DefaultSingletonBeanRegistry 类的registerDependentBean()方法。 3. DefaultSingletonBeanRegistry 的 registerDependentBean()方法对属性注入12345678910111213141516171819202122232425262728293031323334353637//为指定的Bean注入依赖的Beanpublic void registerDependentBean(String beanName, String dependentBeanName) { // A quick check for an existing entry upfront, avoiding synchronization... //处理Bean名称，将别名转换为规范的Bean名称 String canonicalName = canonicalName(beanName); Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName); if (dependentBeans != null &amp;&amp; dependentBeans.contains(dependentBeanName)) { return; } // No entry yet -&gt; fully synchronized manipulation of the dependentBeans Set //多线程同步，保证容器内数据的一致性 //先从容器中：bean名称--&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean synchronized (this.dependentBeanMap) { //获取给定名称Bean的所有依赖Bean名称 dependentBeans = this.dependentBeanMap.get(canonicalName); if (dependentBeans == null) { //为Bean设置依赖Bean信息 dependentBeans = new LinkedHashSet&lt;&gt;(8); this.dependentBeanMap.put(canonicalName, dependentBeans); } //向容器中：bean名称--&gt;全部依赖Bean名称集合添加Bean的依赖信息 //即，将Bean所依赖的Bean添加到容器的集合中 dependentBeans.add(dependentBeanName); } //从容器中：bean名称--&gt;指定名称Bean的依赖Bean集合找查找给定名称Bean的依赖Bean synchronized (this.dependenciesForBeanMap) { Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName); if (dependenciesForBean == null) { dependenciesForBean = new LinkedHashSet&lt;&gt;(8); this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean); } //向容器中：bean名称--&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息 //即，将Bean所依赖的Bean添加到容器的集合中 dependenciesForBean.add(canonicalName); }} 通过对 autowiring 的源码分析，我们可以看出，autowiring 的实现过程： a、对 Bean 的属性代调用 getBean()方法，完成依赖 Bean 的初始化和依赖注入。b、将依赖 Bean 的属性引用设置到被依赖的 Bean 属性上。c、将依赖 Bean 的名称和被依赖 Bean 的名称存储在 IOC 容器的集合中。 Spring IOC 容器的 autowiring 属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean 的依赖关系在 配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是 Spring 容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑 。","link":"/2019/08/21/Spring-2019-08-渐入Spring-DI/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Spring IOC","slug":"Spring-IOC","link":"/tags/Spring-IOC/"},{"name":"Spring DI","slug":"Spring-DI","link":"/tags/Spring-DI/"},{"name":"Spring AOP","slug":"Spring-AOP","link":"/tags/Spring-AOP/"},{"name":"事务","slug":"事务","link":"/tags/事务/"},{"name":"transaction","slug":"transaction","link":"/tags/transaction/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"IOC","slug":"IOC","link":"/tags/IOC/"},{"name":"DI","slug":"DI","link":"/tags/DI/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"单例","slug":"单例","link":"/tags/单例/"},{"name":"装饰者","slug":"装饰者","link":"/tags/装饰者/"},{"name":"观察者","slug":"观察者","link":"/tags/观察者/"},{"name":"委派","slug":"委派","link":"/tags/委派/"},{"name":"模板方法","slug":"模板方法","link":"/tags/模板方法/"},{"name":"原型模式","slug":"原型模式","link":"/tags/原型模式/"},{"name":"策略","slug":"策略","link":"/tags/策略/"},{"name":"适配器","slug":"适配器","link":"/tags/适配器/"},{"name":"代理","slug":"代理","link":"/tags/代理/"}],"categories":[{"name":"建站笔记","slug":"建站笔记","link":"/categories/建站笔记/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}